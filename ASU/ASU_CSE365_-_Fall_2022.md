# ASU CSE365 - Fall 2022
>
> <https://www.youtube.com/playlist?list=PL-ymxv0nOtqqW1sDfN6UGUfJTcYqYH9CM>
>
## 1. CSE 365 - Connor - Live Session - 2022.08.23

### 1.1 回顾上次课内容

上次课主要介绍了微服务的概念以及相关技术。

微服务架构是一种分布式系统架构,将单一应用程序划分成一组小型服务,从各种角度独立部署和维护。每个服务运行在自己的进程中,服务之间通过轻量级机制进行通信,通常是通过HTTP资源API。

与传统单体应用相比,微服务架构的优点包括:

- 每个服务关注单一责任,独立开发和维护,能够快速交付和迭代;

- 根据服务前后依赖关系进行独立升级和扩缩容;

- 增强服务内聚性,降低耦合性;

- 不同服务可以使用不同的语言和开发框架;

- 每个服务都有自己的数据库,消除数据障碍。

常用的微服务技术包括Docker容器、Kubernetes集群管理、服务发现与负载均衡、API Gateway、分布式追踪等。

### 1.2 Spring Cloud与Spring Boot

Spring Cloud是在Spring Boot基础上构建的微服务开发平台,它为开发者提供了在分布式环境中开发应用的工具,例如配置管理、服务发现、断路器、路由等常用模块化功能。这些功能以 SpringBoot的开发风格整合在一起,开发者可以充分利用这些功能来开发分布式系统。

Spring Boot是一个快速开发框架,目的是简化Spring应用的开发,内置Tomcat、Jetty等web容器,使用一些依赖和配置就可以快速构建一个独立运行的基于Spring的应用程序。所以开发微服务时采用Spring Boot可以快速构建出功能完整的微服务应用。

Spring Cloud提供的功能主要包括:

- 配置中心:管理配置文件,支持动态刷新配置
- 服务注册与发现:各种服务注册到Eureka服务治理中心
- 路由控制:通过Zuul实现基于路由的请求转发
- 负载均衡:Ribbon实现客户端背部负载均衡
- 服务调用:Feign通过接口定义方式调用其他服务
- 断路器:Hystrix实现服务降级,执行超时与容错保护
- 消息总线:消息驱动微服务间通信

Spring Cloud通过这些功能,有效地实现服务治理、负载均衡、熔断保护等,大大简化了微服务应用开发的复杂度。

## 2. CSE 365 - Connor - Live Session - 2022.08.24

### 2.1 Docker

Docker是一个开源的应用容器引擎,能够很好地用于部署和调试应用程序。它提供了一个额外的抽象层,在操作系统的基础上运行容器化的应用程序。

Docker利用Linux的cgroup和namespace等技术,将软件运行在隔离的容器里,实现应用与环境的集装箱化。特点如下:

- 隔离:容器之间相互隔离,每个容器都有一套自己的内核空间,系统资源和进程

- 资源限制:容器可指定资源限额,防止一个容器影响其他容器

- 依赖管理:将应用及其所有依赖打包在一个容器中,实现移植性较强的应用交付和部署

- 快速启动与停止:容器的启动和停止速度比完整操作系统快很多

- 文件系统层面独立:容器之间文件系统独立,不会影响其他容器和宿主机

- 高可移植性:基于标准化操作接口,支持主流操作系统

常用Docker命令包括:docker build、docker run、docker stop、docker rm、docker ps等。Docker主要用于开发、测试与运维中部署微服务应用。

### 2.2 Kubernetes

Kubernetes(k8s)是Google开源的容器集群管理系统。它可以自动处理容器调度、规划、部署、维护等任务。常用于生产环境中运行Docker容器并保证容器高可用。

Kubernetes有以下主要组成:

- Master:提供API并负责全局管理
- Node:工作节点,运行Docker容器  
- Pod:Kubernetes本身最小调度单位,通常一个Pod对应一组容器
- Service:提供应用负载均衡和服务发现
- Ingress:外部流量入口控制器
- Volume:管理持久化数据存储
- Deployment:描述部署信息的API对象,操控Pod的状态

它相比Docker新增以下主要功能:

- 服务发现和负载均衡
- 存储管理
- 自动弹性伸缩
- 应用配置管理
- 日志收集
- 自动滚动更新
- 应用级别自愈

Kubernetes被广泛应用于微服务生产环境的集群化部署和管理。

## 3. Program Misuse - Connor - Live Session - 2022.08.29

### 3.1 软件的误用

软件的误用可能导致安全问题和法律后果。包括:

- 未经授权使用软件,Violate软件许可协议
- 进行黑客攻击或其他违法活动
- 使用软件从事诈骗、盗窃或其他欺诈行为
- 使用办公软件从事非法商业活动
- 使用社交软件传播虚假信息或骚扰别人
- 将软件用于攻击或破坏其他系统

应慎用软件,确保符合其使用目的和法律规定。

### 3.2 个人信息与隐私

在使用软件时应注意个人信息安全和隐私保护:

- 不随意公开个人隐私信息如生日、地址等
- 不把银行卡或其他敏感信息分享给未知来源
- 注意社交软件信息公开范围和权限设置
- 使用强密码保护账号并定期修改
- 不下载或使用可疑软件,防止机器被控制或信息泄露
- 不保存重要文件到公共云端服务中
- 不使用同一个密码在多个网站登录
- 理解软件隐私政策并谨慎同意第三方应用访问权限

如无必要不要过多地分享个人信息,采取积极的安全态度保护自己的隐私。

### 3.3 版权与知识产权

在使用软件过程中应遵守相关知识产权法律:

- 不传播软件原始码或二进制文件给其他人
- 不进行非法下载或使用软件盗版版本
- 不在未获得授权的情况下修改软件源码或二开发功能
- 不擅自转让或出售他人的原创软件作品
- 使用开源软件时遵守开源协议要求给出正确署名和许可说明
- 不使用软件从事侵犯他人著作权的行为如音乐视频下载转发
- 使用软件 properly引用和致谢他人知识产出

尊重自由软件运动思想,使用软件应保护作者的合法权益。

## 4. Program Misuse - Connor - Live Session - 2022.08.30

### 4.1 使用软件注意事项

在使用软件时应关注:

- 遵循软件使用许可协议,不得进行任何非法或未授权的使用方式

- 确保软件版本更新完整,及时安装补丁以提升安全性

- 不点击未知来源链接或下载可疑程序,防止系统被破解和入侵

- 使用防火墙和安全软件,定期进行系统扫描以清除潜在风险

- 创建强密码保护账号,不将隐私信息泄露给未知来源

- 不在公共场合使用个人硬件和账户登录软件

- 不随意打开附件或点击链接,防止恶意程序自动运行

- 理解并审慎同意软件要求的各种权限,减少信息泄露风险

正确使用可以提升安全性和用户体验。

### 4.2 网络法律常识

在网络空间进行各种活动时,也需要遵守一些法律规范,主要包括:

- 网络安全法:保护网络空间和重要信息基础设施安全运行

- 网络个人信息保护法:规范网络个人信息收集与处理标准

- 反单位违法危害计算机信息系统行为法:禁止进行网络攻击等活动

- 反恐法:禁止传播极端思想和组织恐怖活动

- 知识产权法:规范版权、商标、专利等知识产权范围

- 反垄断法:禁止网络平台滥用市场支配地位

不理解法律规定会面临行政罚款或刑事处罚,在网络上也要守法。

## 5. Talking HTTP - Connor - Live Session - 2022.09.01

### 5.1 HTTP简介

HTTP(Hypertext Transfer Protocol)是万维网上应用最广泛的一种网络传输协议,基于请求-响应模型的状态less协议。

HTTP的主要特点和组成:

- 基于TCP/IP通信,Port 8080通常用于HTTP通信

- 无状态协议,每次请求独立,服务器不能保存客户端会话信息

- 使用URL定位网络资源,URI作为唯一标识

- 使用请求方法表明请求动作,比如GET、POST、PUT、DELETE

- 请求消息包含请求行、请求头部和请求正文三部分

- 响应消息包含状态行、响应头部和响应正文三部分

- GET请求只获取资源,POST请求传输实体主体,PUT修改资源

HTTP为万维网数据传输提供了统一的接口,广泛应用于网页、API接口通信等场景。

### 5.2 HTTP状态码

HTTP状态码指示请求处理结果,主要分类:

2xx:请求成功,如200 OK

3xx:重定向,如301 Moved Permanently

4xx:客户端错误,如404 Not Found

5xx:服务器错误,如500 Internal Server Error

状态码紧贴响应消息头部,能清晰反馈请求结果。开发人员通过状态码可以判断是否发生错误需要追根究底。

常见状态码的细分和含义也很重要,方便了解请求的具体情况。状态码体现了HTTP协议的响应标准。

## 6. Talking HTTP - Connor - Live Session - 2022.09.12

### 6.1 HTTP报文格式

HTTP报文由开始行、消息头和消息体三部分组成:

- 开始行包含请求方法、请求资源URL和HTTP版本,格式为“请求方法 请求URL HTTP/1.1”

- 消息头使用键值对的形式记录各种信息,如Host、Content-Type等

- 消息体是请求的实体主体,在GET请求中为空,在POST请求中作为正文内容

一条HTTP请求示例:

```
GET /index.html HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0
Accept: text/html

## 消息体为空
```

### 6.2 HTTP请求方法

主要请求方法包括:

- GET:从服务器请求资源内容,不应产生副作用
- POST:向特定的资源提交要执行的操作和数据
- PUT:向特定的资源上传其最新内容
- DELETE:从服务器删除特定的资源
- HEAD:与GET相同但只返回消息报头而不返回报文主体
- OPTIONS:获取该资源的可用请求方法

不同方法对应不同语义,如表单提交一般用POST而非GET。

### 6.3 HTTP响应状态码

常见响应状态码分类:

2xx:成功,如200 OK
3xx:重定向,如301 Moved Permanently
4xx:客户端错误,如404 Not Found
5xx:服务器错误,如500 Internal Server Error
1xx:信息性状态码

状态码明确告诉客户端请求结果,开发者可以通过判断状态码来进行后续处理。

## 7. Assembly Crash Course - Connor - Live Session - 2022.09.19

### 7.1 汇编语言简介

汇编语言是一种低级编程语言,比机器语言更紧密地映射到特定处理器的指令集结构。

与高级编程语言相比,汇编语言具有更快的执行速度和更小的代码体积,但可读性更差。

汇编使用备用操作码名称和寻址模式表示机器指令,支持变量和符号,但无数据类型和高级结构概念。

常见汇编语言包括:x86汇编、ARM汇编、MIPS汇编等架构专用语言。

### 7.2 汇编指令

汇编指令通常包括:

- 数据操作指令:MOV、PUSH、POP等移动数据
- 算术运算指令:ADD、SUB、MUL等四则运算
- 对比指令:CMP进行比较,FLAGS寄存器存储结果
- 控制流指令:JMP、JZ、CALL、RET等流程控制
- 输入/输出指令:IN、OUT与外围设备交互
- 其他系统指令:INT、RET访问系统服务

指令操作数可以是寄存器、内存地址或常数。不同架构指令格式也有差异。

### 7.3 汇编程序示例

一个简单的Hello World程序汇编代码:

.data
  msg: .ascii "Hello World\n"

.text
  mov edx, len
  mov ecx, msg
  mov ebx, 1
  mov eax, 4
  int 0x80

  mov eax, 0
  int 0x80

 len: .long 0x0b

含义为输出字符串到标准输出并返回0。

## 8. Assembly Crash Course - Connor - Live Session - 2022.09.21

### 8.1 汇编数据类型

汇编语言的数据类型包括:

- 字节(byte):8位,使用单字节指令操作
- 字(word):16位,Intel386及后继品使用
- 双字(dword):32位,Intel80386及后继品使用
- 段(segment):16位,存放程序或数据的地址部分
- 字形(character):等同于字节
- 字符串:以空字符结束的字符序列

以上数据类型可以作为操作数传递给指令。

### 8.2 寻址模式

寻址模式决定操作数的有效地址,常见模式包括:

- 寄存器直接寻址:操作数直接使用寄存器内容
- 寄存器间接寻址:通过寄存器获得操作数内存地址
- 导致寻址:基于基址寄存器地址计算出操作数地址
- 立即数寻址:操作数为立即数,不需要计算
- 索引寻址:基于索引寄存器和偏移量计算地址

不同模式会影响指令效率。模式选择取决于代码性能需求。

### 8.3 汇编程序结构

常见汇编程序结构:

- 数据区:.data中定义初始化数据
- 文本区:.text中定义机器码
- 标号:使用标号为程序段或数据分配名称
- 宏:定义可重复使用的代码片段
- 过程:类似函数,使用CALL和RET进入和退出
- 条件跳转:JZ(IF)、JNZ(ELSE)等控制流程
- 注释:以';'开头对代码进行说明
- 定义符号:标明程序入口点和结束点

结合数据类型和寻址模式进行组合开发程序。

## 9. Assembly Crash Course - Connor - Live Session - 2022.09.26

### 9.1 汇编程序调试

汇编程序调试需要的工具包括:

- 汇编器:将汇编代码转换成机器码例如nasm
- 链接器:连接对象文件和库实现重定位形成可执行文件
- 调试器:如gdb用于程序调试与单步执行

常见调试操作包括:

- 设置断点:bp用于在代码处设断点
- 单步执行:si单条执行,n过程序运行至下一个断点
- 查看寄存器:info registers查看各个寄存器值
- 查看内存:x查看内存地址内容
- 修改内存:set var = value修改变量值
- 继续执行:c继续运行程序

使用调试器可以观察程序运行状态、定位Bug问题。

### 9.2 汇编函数

汇编函数调用方式与 asm语言其他程序结构相同,主要特征:

- 使用标号命名函数名
- 函数声明时规定参数通过寄存器或堆栈传递  
- 函数内引用外部变量或常量需要注意作用域
- 使用CALL引用函数,函数结束RET返回
- 函数可以定义在.text或独立的文件中
- 参数传递方式影响调用约定和栈帧布局

举例一个简单参数求和函数的实现。

函数编程是汇编的重要应用,可以封装公用功能供主程序调用。

## 10. Assembly Crash Course - Connor - Live Session - 2022.09.28

### 10.1 汇编与C交互

汇编与C语言可以通过以下方式进行交互:

- 调用C函数:在汇编中使用cdecl调用约定引用C函数
- 声明外部C函数:扩展汇编程序使用外部函数
- 定义C可以调用的汇编函数:声明为extern让C调用
- 包含C头文件:使用INCLUDE指令包含方法签名
- 共享数据:C中的全局变量可以在汇编直接访问
- 指针:指针可以在C和汇编之间传递
- 结构体:C结构体可以在汇编中直接操作

两者通过这种集成可以相互呼应,完成功能模块定制。

### 10.2 NASM语法

NASM是常见的X86汇编器之一,它支持Intel和AT&T风格语法。

NASM语法包含:

- 段指令:SECTION定义代码/数据区域
- 数据定义:DEFINE、DB、DW等定义常量
- 标号:标签指令方便引用
- 指令:操作码及寻址模式
- 注释:;单行注释
- 预处理: %define等预定义宏
- 条件编译:%if/%else
- 包含:%include引入头文件

NASM可以用于Linux、DOS和Windows平台。语法简洁灵活使其成为流行汇编器。

通过NASM汇编程序后可以得到目标文件,进一步链接成可执行文件。

## 11. Building a Web Server - Connor - Live Session - 2022.10.05

### 11.1 基于TCP的网络编程

网络编程常用的传输层协议有TCP和UDP。

- TCP提供可靠的连接服务和流式数据传输。
- UDP为无连接的单机传输协议,不保证可靠性。

基于TCP协议开发网络应用常见步骤:

1. 创建套接字Socket
2. 绑定IP和端口Bind
3. 监听等待连接Listen
4. 接受客户端连接Accept
5. 读写数据Read/Write
6. 关闭连接Close

### 11.2 简单web服务器

一个基本的HTTP文件服务器可以实现以下功能:

- 在指定端口监听客户端请求
- 解析HTTP请求行获取方法和文件路径  
- 打开文件读取内容发送响应
- 设置响应行和头部返回状态和类型
- 主循环持续等待和响应多个请求

以C语言实现一套 TCP网络库,基于此开发一个简易静态文件HTTP服务器。

该程序将成为网络应用的基础,了解TCP编程机制。

## 12. Building a Web Server - Connor - Live Session - 2022.10.06

### 12.1 HTTP响应报文格式

HTTP响应报文包括三个必要部分:

1. 状态行

格式:HTTP版本 状态码 状态消息
例如:HTTP/1.1 200 OK

2. 响应头

通过键值对形势携带元数据,常见字段:
Content-Type: text/html
Content-Length: 123

3. 消息体

包含请求资源的具体内容,如HTML文档内容

状态码决定了请求是否成功,内容类型决定了资源格式。

头部和状态提供了关键的请求语义信息。

### 12.2 文件服务器实现

具体实现步骤:

1. 接受客户端连接

2. 解析请求行获取请求方法和目标文件路径

3. 拼接文件路径并打开文件

4. 设置200状态行和Content-Type头

5. 读取文件内容构建消息体

6. 构建完整的HTTP响应报文

7. 响应报文发送给客户端

8. 关闭文件并socket

9. 循环监听下个请求

能够解析HTTP报文并提供简单的文件服务功能。

## 13. Building a Web Server - Connor - Live Session - 2022.10.12

### 13.1 文件服务器优化

为提高文件服务器效率,需要考虑以下优化方案:

1. 支持Keep-Alive连接

定长的HTTP/1.1连接可以处理多个请求。

2. 并发处理

利用多进程或线程同时处理多个客户端连接请求。

3. 缓冲 I/O

读写文件使用缓冲区可以提高效率。

4. 支持静态资源类型

为js、css和图片等设置正确的Content-Type。

5. 错误处理

处理文件未找到等常见错误,给出标准格式报文返回。

6. 参数验证

过滤特殊字符避免路径注入等安全隐患。

7. 日志记录

访问日志分析可以了解服务器状态和热点资源。

采用这些技术可以让小型文件服务器也能满足基本需求。

### 13.2 CGI与动态资源

利用Common Gateway Interface(CGI)接口,可以提供动态生成的页面内容:

1. CGI程序运行在单独的进程中。

2. 服务器接收并解析POST或GET请求。

3. 以环境变量的形式传递请求信息给CGI程序。

4. CGI程序处理逻辑并输出HTTP响应。

5. 服务器返回CGI输出内容给客户端。

例如用CGI编写简单搜索页,实现服务器内可配置的动态功能。

## 14. Building a Web Server - Connor - Live Session - 2022.10.13

### 14.1 HTTP/1.1特性

相对于HTTP/1.0,HTTP/1.1协议定义了以下重要改进:

- 支持通过Connection头确定持久连接,默认Keep-Alive

- GET和POST请求可以包含消息体

- 支持Http状态码100表示继续处理请求

- 定义了更丰富的状态码如307暂时重定向

- 支持内容协商机制根据客户端请求选择响应版本

- 引入了包含表情和条件请求能力

- 扩展了缓存验证机制提升效率

实施HTTP/1.1可以支持更多类型的请求和响应语义。

### 14.2 静态内容压缩

为减小响应体积,可以对静态资源采取以下压缩措施:

- GZIP压缩:服务器使用gzip对html/css/js等进行压缩传输

- Brotli压缩:新一代更高效的网页压缩算法

- 图片优化:采用无损JPG或WebP格式,减小尺寸压缩图片

- 批处理CSS和JS:合并多个小文件,减少HTTP请求次数

- CDN加速内容分发:通过CDN边缘节点提供近距离访问

合理利用上述静态资源优化技术,可以有效提升页面加载速度和用户体验。

## 15. Intercepting Communication - Connor - Live Session - 2022.10.17

### 15.1 网络流量监测

监测网络请求可以采用以下方法:

- 代理服务器:配置系统代理,全部流量通过代理服务器转发。

- 监视套接字:使用抓包工具监听套接字,获取往来报文内容。

- 拦截连接:通过HOOK相关系统调用截取建立连接的流量。

- 运行时注入:在程序运行时使用LD_PRELOADHOOK相关函数。

- 驱动程序截获:开发网卡驱动程序捕获网卡数据包。

以上方法都需要 Root权限或程序调整支持。目的在于观察网络行为和程序调用过程。

### 15.2 HTTPS流量解密

由于HTTPS采用TLS加密传输,单纯监听网络无法解密内容。可以采取以下措施:

- 抓包代理:设置系统代理,抓包软件作为中间人解密截取流量。

- 证书干预:使用自签名根证书替换系统证书,中间人攻击解密HTTPS。

- CRL项改写:篡改CRL执行中间人攻击以解密HTTPS请求响应。

- lib抓包:HOOK libcurl等函数劫持SSL连接进行解密和重写。

但这些方法都可能被现代浏览器识别出安全问题拒绝连接。

## 16. Intercepting Communication - Connor - Live Session - 2022.10.18

### 16.1 拦截网络报文

在Linux系统中,可以使用tcpdump命令实时捕获网络报文:

- tcpdump是一个命令行工具,直接运行即可实时打印出所有的报文

- 支持抓取特定接口的报文,如tcpdump eth0

- 可以通过过滤表达式过滤出指定协议或地址的报文

- 抓包结果可以导出为pcap文件格式,使用Wireshark进行分析

- 抓包需要ROOT或CAP_NET_RAW权限支持

tcpdump通过抓包核心可以实时的分析所有网络流量,不需要程序支持。

### 16.2 进程跟踪

跟踪单个进程的系统调用可以使用strace工具:

- 以追踪模式运行目标程序,如strace ./a.out

- 打印出目标进程所有的系统调用记录

- 可过滤指定系统调用 verbose 选项

- 调试程序找出非常见的系统调用

- 分析程序的IO、网络和文件访问行为

- 需要DEBUG_SYSCALL or CAP_SYS_PTRACE权限

strace是调试和分析程序行为的有效方式之一。

## 17. Intercepting Communication - Connor - Live Session - 2022.10.24

### 17.1 Library Hooking

使用库钩子技术可以在程序调用标准库函数时插入自定义代码:

- LD_PRELOAD将动态链接器置为可控路径

- 写钩子函数实现相同接口签名如open()  

- 基础库函数在内部进行函数劫持调用钩子函数

- 钩子函数可以打印参数、修改返回值等

- 需要重新编译静态链接即可注入任意程序

这种方式无需程序支持,但会降低性能。

### 17.2 劫持系统调用

可以通过ptrace系统调用完成进程跟踪并劫持其系统调用:

- PTRACE_ATTACH附着被调试进程PT_CONT继续执行

- 使用PT_GETREGS收集当前上下文寄存器状态

- PTRACE_POKETEXT修改SYSCALL指令劫持特定调用

- PTRACE_SYSCALL单步跟踪到期待系统调用后截获

- 分析系统调用参数并选择继续或中断执行

这种方式可以针对关键系统调用进行 mehr深入监控和修改。

## 18. Intercepting Communication - Connor - Live Session - 2022.10.26

### 18.1 Hook动态链接库函数

使用LD_PRELOAD技术Hook共享库函数的具体步骤:

1. 定义钩子函数,函数签名与原函数相同

2. 使用LD_PRELOAD环境变量 指定注入的共享库

3. 在钩子函数中打印调用信息或修改逻辑

4. 重新编译生成共享库,.so文件设置rpath

5. 运行目标程序,原函数调用将进入钩子

这种方法无须程序源代码,适用于黑箱测试。

### 18.2 注入动态链接

也可以使用ptrace系统调用注入打桩代码实现Hook:

1. 得到目标进程PID并attach

2. 解析动态 linking信息获取函数地址

3. 修改text区代入打桩指令

4. 设置断点恢复执行单步跟踪

5. 到达打桩处获取调用信息

6. 继续执行或中断追踪进程

这种注入方式更低级且需要调试目标进程。

两种方式都可以实现函数Hook动态捕获程序行为。

## 19. Intercepting Communication - Connor - Live Session - 2022.10.31

### 19.1 IDA反汇编

IDA是广泛使用的反汇编器,主要功能:

- 支持多种平台可执行文件类型分析

- 反汇编机器码还原汇编指令

- 动态分析反脱壳隐藏代码区域

- 自动识别常用代码结构如函数、跳转等

- 交互式反汇编界面修改程序流程图

- 提供汇编语法高亮和调试支持

- 脚本化API可以自动化反汇编任务

IDA能深入解析程序内部机制,是后端安全工作的重要工具。

### 19.2 GDB调试

GDB是GNU项目开发的通用调试器,支持C/C++程序调试:

- 附着目标进程对其进行调试分析

- 设置/清除断点控制执行流程

- 查看程序底层信息如寄存器、内存等

- 单步/续行执行程序追踪代码流

- 查看源代码打印变量信息

- 插件机制扩展新功能如隐藏断点

- 交互与 скрипτ化界面丰富使用场景

GDB能够低层级调试程序运行情况和异常。

## 20. Cryptography - Connor - Live Session - 2022.11.08

### 20.1 对称加密

对称加密使用同一个密钥进行加密和解密,常见算法有:

- DES:早期标准算法,密钥长度56位,不再安全

- AES:当前国际标准算法,密钥长度可以是128/192/256位

- 3DES:DES的加强版,使用168位密钥

- Blowfish:块密码,速度快但不再活跃

对称加密适用于关键数据保密传输,需要彼此信任的情况下共享密钥。

### 20.2 非对称加密

非对称加密使用不同密钥进行加密和解密,常见算法有:

- RSA:目前使用最广泛的算法,基于大数分解问题

- DSA:数字签名算法所使用的算法

- ElGamal:和RSA类似但是基于离散对数问题

非对称加密解决了密钥分发问题,适用于 open 环境的数字签名和密钥交换。

区分了公钥和私钥,公钥用于加密私钥用于解密。

## 21. CSE365 - Connor - Live Session - 2022.11.16

### 21.1 数字签名

数字签名用于验证信息的完整性和发起者身份。

- 使用发送方的私钥进行数字签名

- 接收方使用公钥验证签名是否正确

- 只有发送方持有私钥才能生成此签名

常用数字签名算法包括:

- DSA:数字签名标准,基于离散对数问题

- ECDSA:椭圆曲线数字签名算法,相对DSA更短更高效

- RSA:基于RSA算法的数字签名实现

数字签名解决了非对称加密中身份识别的问题。

### 21.2 数字证书

数字证书由证书颁发机构(CA)签发,用于在openssl环境下验证用户身份。

- 证书包含主体公钥和其他识别信息的数字签名

- Web服务器申请自签名证书或由第三方CA签发证书

- 客户端使用CA公钥验证证书签名的正确性

- 验证通过则信任该证书持有者的身份

数字证书验证HTTPS网站的身份,构建头尾一致的认证链机制。

## 22. Web Security - Connor- Live Session - 2022.11.21

### 22.1 跨站脚本攻击(XSS)

- XSS攻击利用Web页面动态更新机制注入 malicious代码

- 攻击者令受害者点击poisoned页面或链接嵌入XSS payload

- 受害者浏览器执行攻击代码,可窃取sessionid或其他敏感数据

- 防范措施:

    1. 过滤或编码用户输入内容降低攻击机会

    2. CSP内容安全策略限制脚本来源避免被利用

    3. 定期维护补丁避免被已知漏洞利用

### 22.2 注入攻击(SQL、命令)

- 注入攻击利用不当输入验证漏洞执行技术命令

- SQL注入通过修改SQL语句导致非法访问数据库

- 命令注入利用网站对技术命令的解释执行系统命令
  
- 防范措施:

    1. 对所有输入进行严格过滤验证合法性

    2. 使用prepared语句或 ORM框架参数化查询

    3. 限制程序对命令执行的访问权限

正确处理用户输入,避免泄露系统访问能力,是防御注入的关键。

## 23. Web Security - Connor - Live Session - 2022.11.28

### 23.1 反盗链

- 反盗链解决他人未授权使用自己网站资源的问题。

- Nginx使用Referer拦截非法请求:

```nginx
if ($http_referer !~ ^(https?://)?(.+\.)?mydomain\.com(/.*)?$) {
  return 403;
}
```

- Apache使用禁用某站点引用:

```apache
RewriteEngine on
RewriteCond %{HTTP_REFERER} !^https://(www\.)?yourdomain.com [NC] 
RewriteRule \.(jpe?g|gif|bmp|png|ico|wav|mov|mp3)$ - [F]
```

### 23.2 CSRF保护

- CSRF利用用户登录状态在第三方网站自动发起请求

- 表单加入CSRF Token难以伪造,每个请求必须提供正确Token

- Token存储在Session中或HTTP Only Cookie防篡改

- GET请求不修改状态不受影响,POST需要判断Token合法性

- 一些API如漏洞扫描平台提供无损接口避免干扰

正确处理状态改变请求和使用CSRF Token是重要的防御措施。

## 24. Web Security - Connor - Live Session - 2022.11.30

### 24.1 会话管理

- 会话识别sessionId存储在Cookie中或URL参数传输

- Id必须难以预测以防止被窃取

- Id存储在HTTP Only Cookie不可访问墻JS降低风险

- Id有效期设定较短如半小时避免长期攻击

- 使用橡胶唧唧误实现会话同源策略限制请求源

- 定期增强Id反转义机制增加攻击难度

良好的会话管理设计能有效防御会话劫持攻击。

### 24.2 输入验证

- 对所有输入类型如files dns执行格式和内容检查

- 过滤特殊字符如注释符空格报警而非直截除去

- 长度限制和数据类型检查预防溢出攻击

- 动态正则校验输入结构合法性

- NoSQL注入需考虑特别字符如$。与括号

严格的输入标准化过滤可以杜绝大部分注入风险。
