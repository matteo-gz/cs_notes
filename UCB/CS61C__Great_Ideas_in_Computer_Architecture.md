# CS61C: Great Ideas in Computer Architecture

> <https://www.youtube.com/playlist?list=PL0j-r-omG7i0-mnsxN5T4UcVS1Di0isqf>

## 1. [CS61C FA20] Weekly Lecture 01.LIVE - Great Ideas in Computer Architecture, Intro

### CPU的演变

- 在20世纪30-40年代,计算机体积很大,使用了许多电路板和插件来运算。

- 1950年,发明了集成电路,把晶体管结合到一起,开始将计算机缩小。

- 1960年代,发明了集成电路,将电路整合到一个小芯片中,这对计算机体积的缩小很重要。

- 1970年代,CPU开始采用微处理器的形式。Intel在1971年发明第一款商用微处理器4004。

- 1980年代,80386微处理器诞生,采用32位架构,推动计算机向个人计算机转型。

- 1990年代,CPU开始采用超级紧凑封装等技术,可整合百万级的晶体管进行高速运算。

- 2000年代后,多核CPU应用广泛,提高计算能力。现代CPU甚至可整合上千个执行核心用于并行计算。

### 计算机组成

计算机主要组成单元包括:

- CPU(中央处理单元):负责计算和控制其他组件进行计算。

- 内存:存储程序和数据,CPU通过加载程序进行运算。

- 外设接口:如USB、串口等,用于连接输入输出设备。

- 显示器:输出计算结果。

- 电源供应装置:为整个计算机提供电源。

- 输入/输出设备:如鼠标、键盘、存储设备等,用于输入和输出数据。

计算机通过有序组合这些单元,读取程序指令,加载数据,进行运算计算,输出结果,完成不同功能的应用。

### 计算机架构演变

计算机的架构也随着技术发展而进行不断优化:

- 寄存器机器架构:使用少量高速寄存器存储。

- 利用存储器架构:利用内存进行中央处理。

- 向异构集成架构转变:周边处理单元整合CPU。

- 并行计算架构:多核结构实现并行计算。

- 三维集成技术:提高组件集成度。

计算机架构的目的是提高计算效率,减小体积,降低成本,实现更强大的计算能力。这需要CPU、内存和外设的深度融合。

## 2. [CS61C FA20] Lecture 02.1 - Number Representation: Intro, Bits can be anything

### 数字与 analog 数据的转换

- 大部分数据源于实体世界中为模拟形式存在。

- 为计算机处理,需要将模拟数据采样后 quantification 转成数字数据。

- 采样是定期记录模拟信号的幅值。quantization 是将采样值划分到离散的格位数值上。

### 计算机组成与运算

- 计算机主要组成单元包括:CPU、内存、外设接口、显示器、电源等。

- 计算机通过加载程序到内存,在CPU执行指令运算,向外部设备输入输出数据,完成应用任务。

### 数字表示方法

- 数字可以使用二进制位表示任何信息。比如使用5位表示26个字母、7位表示ASCII码等。

- 随着不同语言需求的增加,诞生了统一多语言字符集Unicode标准。

- 一个bit可以表示逻辑值、颜色通道值、位置地址等任意数量的项目。

### 位与表示数量的关系

- N位可以表示2^N种状态,即2^N个不同的数字或项目。

- 如果需要表示S个项目,则所需的位数为ceil(log2(S))。

## 3. [CS61C FA20] Lecture 02.2 - Number Representation: Conversions

### 数字的转换

- 数据在计算机中以二进制形式存储,但我们使用的是十进制。所以需要进行进制转换。

- 十进制到二进制:采用除2取余法,从高位到低位记录余数。

- 二进制到十进制:根据位值赋权,各位数字乘以2的对应指数后相加。

### ASCII编码

- ASCII码为英文字母、数字和符号设定了7位二进制编码。

- 例如字母A的ASCII码是01100001,这样就用7 bit即2的7次方可以表示26个字母以及其他符号。

- 但ASCII码不能包含所有语言的字符,后来发展出Unicode标准,支持全球各种文字和符号。

### 补码

- 整数以弹性补码的形式存储在计算机内存中。

- 正数仅保留原值不变。负数将其二进制反转后加1,这样就实现了让原码值的范围对称扩展的目的。

- 这种表示法统一了整数的存储方式,并简化了计算机内的算术运算。

### 对Computer存储数据的影响

- 计算机以二进制形式存储数据需要进行综合考虑人机交互和内部运算效率两个方面。

- 进制转换、编码标准以及整数表示方式的设计都有利于计算机更高效地处理和运算各种数据。

## 4. [CS61C FA20] Lecture 02.3 - Number Representation: Overflow, Sign and Magnitude, One's Complement

### 整数存储位数限制

- 整数在内存中以固定位数表示,超出范围会发生溢出。

- 正数溢出后取其余数继续表示,负数溢出后取补码余数表示。

### 符号-幅值表示法

- 使用最高位表示数的正负号,其余位表示数的幅值。

- 这种表示法比较直观,但进行加法时需要判断正负号,计算量较大。

### 补码表示法

- 对于正数,采用原码表示。

- 对于负数,先将其原码按位取反,然后加1。这样就将整数表示范围对称化处理。

- 这种表示法简化了整数运算,成为计算机中主流的整数存储表示法。

### 反码表示法

- 和补码类似,但对负数直接取反,不采用加1操作。

- 这种表示法在计算机中使用较少,因为与补码相比运算上没有明显优势。

### 数值表示影响因素

- 整数表示方式选择需要考虑可表示范围、存储占用和运算效率几个方面权衡取舍。

## 5. [CS61C FA20] Lecture 02.4 - Number Representation: Two's Complement, Bias, and Summary

### 二补数表示法

- 对正数,原码和二补码一致。

- 对负数,先取反后加1。这种方式使得整数表示范围对称,且简化了乘法和除法运算。

- 以8位二补码为例,-128到127共256种状态,都能用于整数表示。

### 偏置表示

- 偏置表示法用于表示有符号小数。采用二补码表示整数部分,但数字范围右移一位,整数部分添加一个隐藏的1。

- 比如8位有正负127.5,实际上表示的范围是-128到127.

### 数字表示概括

- 数字在计算机内部以二进制存储,需要进行进制转换。

- ASCII和Unicode标准统一了文本字符编码。

- 整数主要采用二补码,以充分利用内存大小和简化运算。

- 小数可以用偏置法或浮点数表示,进一步提高精度。

- 不同表示方法在表示范围、存储占用和运算效率等方面进行权衡。

## 6. [CS61C FA20] Lecture 03.1 - C Intro: Basics: Intro and Background

### C语言简介

- C语言是一种通用的高级编程语言,广泛应用于系统开发及底层编程。

- C语言设计简洁高效,对硬件资源要求低,执行速度快,易于移植。

### C语言历史

- 1968年,肯·汤普森在贝尔实验室发明C语言。

- C语言在微软、苹果和GNU/Linux等操作系统中广泛应用。

- C语言代码可以直接编译成机器码运行,并影响了后来许多语言的设计。

### C程序基本结构

- 源代码文件以.c为后缀。

- 包含头文件进行函数 prototyping。

- 主函数int main()作为程序入口。

- 包含函数定义实现不同功能。

- 返回值表明执行结果。

### C语言特点

- 编译成机器码直接执行,执行效率高。

- 语法简洁灵活 yet 提供低级访问系统。

- 语法较少规则,提高应用广泛性。

## 7. [CS61C FA20] Lecture 03.2 - C Intro: Basics: Compile v. Interpret

### 编译语言与解释语言

- 编译语言如C语言需要先将源代码通过编译器编译成机器码,然后运行。

- 解释性语言如Python会将源代码每一行解释成机器码在运行过程中进行解释执行。

### 编译优势

- 编译后生成的机器码执行效率高,可以直接运行。

- 编译一次后源代码任何地方都可以运行,不依赖解释器。

### 解释优势

- 不需要预编译,编写与运行更连贯。

- 错误信息提示更热,易于调试。

- 解释器可以实时优化源代码。

### 混合模式

- 一些语言采用先编译成中间代码再解释的方式,既保留编译效率又提供边解释调试。

- WebAssembly就是一种在浏览器中使用的中间格式。

总体来说,编译模式用于系统软件和性能关键应用,解释模式用于交互式编程和可扩展性要求高的应用。

## 8. [CS61C FA20] Lecture 03.3 - C Intro: C v. Java and C Syntax

### C与Java比较

- C语言底层级更低,提供面向硬件开发能力但不安全。Java提供了自动垃圾回收和其他安全功能。

- C语言编译出机器码运行速度更快,但缺乏垃圾回收给内存管理带来麻烦。

- Java能运行在多种平台,而C需要重写部分代码移植到其他平台。

### C语法

- 以#include包含头文件

- 以main()为程序入口

- 使用{}括起代码块

- 分号结尾每条语句

- const声明只读变量

- 数据类型包括基本类型(char、int等)和结构体

- 变量声明格式:类型 变量名;

- printf()为格式化输出函数

- scanf()为格式化输入函数

- 返回类型通常为int

C语言提供了底层系统编程的力量同时保持语法相对简单直观。

## 9. [CS61C FA20] Lecture 03.4 - C Intro: Basics: C Syntax

### C语法基本元素

- 关键字:如if、switch、struct等
- 标识符:变量和函数名
- 常量:如数字、字符常量
- 字符串:使用""引起
- 空格和缩进:用于区分代码块和作用域
- 注释://单行注释 /*多行注释*/

### 数据类型

- 基本类型:int、char、float等
- 数组:类型 数组名[大小];如int arr[10];
- 指针:类型 *指针名;如int *p;
- 结构:struct 结构名字{成员};

### 变量定义

- 声明类型+变量名;如int a;
- 在代码任何地方声明变量都可以
- 可以定义常量const禁止修改

### 操作符

- 赋值(=)、算术(+ - * /)、比较(== !=)等
- 逻辑(&& || !)、位(& | ^ ~ << >>)操作符

C语法灵活简单,提供了低级系统编程的能力。

## 10. [CS61C FA20] Lecture 04.1 - C Intro: Pointers, Arrays, Strings: Pointers and Bugs

### 指针基础概念

- 指针是变量,用于储存另一变量的地址。

- 使用 "*" 访问通过指针访问变量。

- 例如:int a = 10; int *p = &a; //p储存a的地址

### 指针常见问题

- 使用未初始化的指针会导致不可预期结果。

- 指向释放的内存区域会产生野指针异常。

- 使用了错误的数据类型也可能crash。

- 指针非法操作可能改写其它变量的值。

### 如何避免指针问题

- 初始化所有指针变量。

- free或delete后置NULL防止野指针。

- 使用正确的数据类型操作指针。

- 不要通过指针修改非设计变量。

- 编译时开启所有警告。

正确使用指针可以提高效率,但也容易出错,需要按规则管理指针以避免bug。

## 11. [CS61C FA20] Lecture 04.2 - C Intro: Pointers, Arrays, Strings: Using Pointers Effectively

### 指针的优点

- 使用指针可以改变参数传递方式,从值传递到引用传递。

- 指针可以实现多级指针或指针数组,增加功能扩展能力。

- 指针操作可以提高内存访问效率,避免值拷贝开销。

### 指针常见用法

- 指向数组名等同于第一个元素地址。

- 通过指针修改变量值或访问动态分配内存。

- 函数传参使用指针可以改变实参。

- 作为返回值返回增强函数功能。

- 实现链表、二叉树等数据结构。

### 使用指针需要注意事项

- 及时释放动态内存避免内存泄漏。

- 防止停止指向非法内存区域的野指针。

- 使用限定指针避免越界访问。

正确使用指针可以大大提高程序效率和扩展能力。

## 12. [CS61C FA20] Lecture 04.3 - C Intro: Pointers, Arrays, Strings: Arrays

### 数组基本概念

- 数组是含有相同数据类型元素的连续存储空间。

- 数组可以通过下标访问其中的任意元素。

- 下标从0开始,最大为数组大小减1。

### 定义和初始化数组

- 类型 数组名[数组大小];

- 例如:int numbers[10]; //10个int数字

- 数组初始化可以直接赋值,也可以分步赋值。

### 数组基本操作

- 访问单个元素数组名[下标]

- 计算数组长度用sizeof(数组名)/sizeof(类型)

- 指针与数组互相转换特别灵活。

- 字符串以'\0'结尾,char数组存储字符串。

数组通过下标访问提高了元素访问效率,不必单独声明每个元素。

## 13. [CS61C FA20] Lecture 04.4 - C Intro: Pointers, Arrays, Strings: Function Pointer Example

### 函数指针例子

定义了两个简单函数x10和x2,分别返回参数乘10和乘2的结果。

声明打印数组函数print_array,用于打印数组元素。

定义了mutate_map函数,用于使用传入的函数指针来修改数组元素值。它接受数组、数组长度和函数指针作为参数。

在main函数中:

1. 声明一个初始化后的整型数组代表π的前三位数字。

2. 打印原数组。

3. 调用mutate_map函数,传入x10函数地址,修改数组每个元素为原值×10。

4. 打印修改后的数组。

5. 再调用mutate_map传入x2函数地址,修改数组每个元素为原值×2。

6. 打印结果数组。

通过这个例子实现了使用函数指针,以更通用的方式操作数组元素值的功能。展示了函数指针在C语言中的应用。

## 14. [CS61C FA20] Lecture 05.1 - C Memory Management: Dynamic Memory Allocation

### 动态内存分配

- C语言支持程序运行期间动态申请和释放内存。

- 主要函数malloc()用于申请内存,返回void指针。

- free()用于释放之前malloc分配的内存。

### malloc语法和使用

- void* malloc(size_t size)

- 比如int* p = malloc(sizeof(int)*n);

- 返回类型void*需要强制类型转换。

- 分配成功返回地址,失败返回NULL。

- 必须释放掉使用完毕的内存防止泄漏。

### 动态内存优点

- 可以在运行期间根据需要动态分配释放内存。

- 避免定义大数组时浪费内存的问题。

- 实现更通用和复杂的数据结构。

但也需要注意内存泄漏问题和安全性。

## 15. Binky Pointer Fun Video C (High Quality 640x560)

### 指针基础

- 指针可以指向内存中的变量(pointee)。

- 首先需定义指针变量,但此时指针为空,还未指向实际变量。

- 需要使用malloc分配内存空间给pointee,指针指向该处内存。

### 指针解引用

- 使用"->"操作符可以访问指针指向的pointee变量。

- 例如:*p = 10;将通过p指针设置pointee的值为10。

### 指针赋值

- 使用赋值运算符可以让一个指针指向另一个指针指向的pointee。

- 此时两个指针实际指向同一个pointee内存,称为“共享”。

### 指针三大原则

1. 指针和pointee分开存在

2. 指针解引用跟随指针访问pointee

3. 指针赋值实现指针共享pointee

视频以生动方式解释指针的基本概念和操作,有助理解C语言指针机制。

## 16. [CS61C FA20] Lecture 05.2 - C Memory Management: Linked List Example

### 链表结构

- 链表通过结构体表示每个节点。

- 节点包含value域和指向下个节点的指针域next。

- 使用next链接每个节点,形成链式结构。

### 添加节点

- 定义链表头指针list。

- malloc分配新节点内存。

- 初始化value域内容,next域指向当前链表头。

- 返回链表头指针,实现添加节点。

### 节点共享

- next域通过指针联通各节点。

- 使得指针都指向同一块内存,即共享内容。

### 源码分析

- 每一行详细解释变量定义、内存分配、赋值操作。

- 帮助理解C语言链表实现机制。

视频通过对链表源代码行解释,详细说明了C语言如何使用结构体和指针实现链表这一常见数据结构。

## 17. [CS61C FA20] Lecture 05.3 - C Memory Management: Memory Locations

### 内存位置

- C语言中,变量存储在内存中不同区域:

  1.栈区(stack):用于保存函数调用期间的局部变量。

  2.静态存储区(static storage):全局变量和静态局部变量存储于此。

  3.堆区(heap):使用malloc/calloc从堆区动态申请内存块。

### 区别属性

- 栈区变量访问速度快,但大小限定。函数返回自动释放。

- 静态存储区变量在程序lifetime内保留,但大小也有限。

- 堆区通过malloc等函数动态申请,大小灵活但需手动释放。

### 指针区别

- 指向栈区和静态区变量的指针在函数退出后仍可用。

- 指向堆区变量的指针必须注意内存释放,否则可能泄漏。

视频说明C语言三大内存区域的概念及特点,有助于正确使用变量和管理内存。

## 18. [CS61C FA20] Lecture 05.4 - C Memory Management: Memory Management

### C的内存区域

C语言中共有三大内存区域:

1. 静态存储区(static storage):程序加载时就已经分配内存,包括全局变量和静态局部变量。不受堆和栈影响。

2. 栈(stack):函数调用时创建临时变量和函数参数。每次调用都会创建一个栈帧,函数返回时释放该帧空间。栈空间自动增长和缩减。

3. 堆(heap):使用malloc和free函数分配释放动态内存。堆内存需要手动管理,直到程序结束才自动释放。

### 堆内存管理

malloc函数从堆中分配连续内存块。与栈区不同,堆区内存请求不一定能成功,malloc可能返回null指针。

free函数释放malloc分配的内存,同时可能会将相邻的内存块合并。

内存分配 foremost可能会产生内存碎片,导致外部碎片。一般使用链表结构管理free内存,所有free内存块链接成一个圈形链表。

常见的内存分配算法包括:

- 首次适合算法(First Fit):使用第一个匹配内存块。

- 最佳适合算法(Best Fit):选择最接近请求大小的内存块。

- 下一个适合算法(Next Fit):下次从上次结束位置开始查找。

内存管理开销包括内存碎片、管理开销大小等。分配策略会影响碎片程度。

## 19. [CS61C FA20] Lecture 05.5 - C Memory Management: When Memory Goes Bad

### 内存问题

C语言中内存出现问题的主要原因:

1. 使用未初始化的内存。

2. 数组下标越界访问。

3. 使用了已经释放的内存。

4. 溢出(buffer overflow),写入超出数组范围。

5. 野指针,指向非法或已经释放的内存地址。

### 后果

内存问题可能导致:

- 应用程序崩溃。

- 安全漏洞被利用。

- 潜在bugs难以查找。

- 数字计算结果错误。

- 泄露敏感数据。

### 解决方法

1. 初始化所有变量。

2. 数组下标检查。  

3. 野指针检查。

4. 引入更严格的内存管理机制。

5. 使用静态分析工具检测内存问题。

6. 注重内存管理结构和流程的正确性。

视频介绍C语言常见的内存问题及后果,指出了预防和解决内存bug的一些方法。

## 20. [CS61C FA20] Weekly Lecture 03.LIVE - Floating Point & RISC-V

### 浮点数

- 计算机使用浮点数表示小数,由三部分组成:符号位、指数位和尾数位。

- 浮点数的精度受存储位数限制,计算可能产生四舍五入误差。

- 常见格式有单精度(32位)和双精度(64位)。

### RISC-V指令集

- RISC-V是开源的指令集体系结构。

- 只有有限的加载/存储和算数逻辑指令,但较X86更简单高效。

- 支持单字大小的有符号整数和浮点数运算。

- 使用小且固定长度的指令集,有利于并行执行。

- 目前广泛应用于微控制器和现实计算机结构设计教学。

视频简要介绍了计算机中浮点数的基本表示方法及RISC-V开源指令集体系结构特点,为学习计算机组成原理奠定基础。

## 22. [CS61C FA20] Lecture 06.2 - Floating Point: Floating Point

### 浮点数表示

- 浮点数使用指数表示法表示:(-1)^s × m × 2^e

- s为符号位,m为尾数,e为指数。

- 浮点數分成三部分存储:符号位1bit,指数域e位,尾数域t位。

- 单精度浮点数(float)指数域8位,尾数域23位。

- 双精度浮点数(double)指数域11位,尾数域52位。

### 指数偏移

- 指数域实际存储的是e+Bias。Bias定值使得指数范围对称。

- 单精度浮点数Bias为127,双精度浮点数Bias为1023。

- 需要考虑Bias进行编码与解码操作。

### 特殊值

- 极值以及Inf,Nan用于特殊处理除零等情况。

视频详细说明浮点数在计算机内的表示方法和细节,帮助理解其数值表示和计算原理。体现出浮点计算与真实数值之间存在差异。

## 23. [CS61C FA20] Lecture 06.3 - Floating Point: Special Numbers

### 特殊浮点数

- 极值:最大最小表示值。超出范围自然取极值。

- 正无限大:所有1为替代指数和尾数。

- 负无限大:全1的补码形式。

- NaN:非数。所有1为指数,至少1位尾数为1。

### 特殊值判断

- 判断无限大:判断指数为最大,尾数非0。

- 判断NaN:判断指数为最大,尾数有1。

- 判断正常数:指数非最大或尾数全0。

### 特殊值处理

- 正负无限大相加减为自身。

- 与NaN的任何运算都返回NaN。

- 0与NaN的除法返回NaN,其他返回自身。

- 与0或者极值的比较都返回False。

视频详细介绍浮点数表示系统中的特殊值,如NaN、无限大等,以及这些值在计算时的特殊性。帮助理解浮点数的完整概念。

## 24. [CS61C FA20] Lecture 06.4 - Floating Point: Examples, Discussion

### 浮点数示例

- 将小数1.111转换为浮点数表示:符号位0,指数129(128+1),尾数1.111。最终为-7.111。

- 将1/3转换为浮点数:符号位0,指数125(127-2),尾数0.01010101。利用二进制小数点移动实现。

- 提供小数0.34和0.11的等值视角解释其尾数含义。

### 浮点数细节

- 尾数可以视为分数或地位和值的和来理解。

- 正态化尾数需要移动二进制小数点到最左,指数相应调整。

- 具体浮点数编码取决于指数和尾数在存储格式中的组合。

视频通过实例详细解释了浮点数与定点数之间的转换,并提供了多种角度解释尾数的含义,有助于深入理解浮点数表示原理。

## 25. [CS61C FA20] Lecture 06.5 - Floating Point: Floating Point Discussion

### 浮点数优点

- 浮点数可以表示的范围广,能表达科学计数法中的较大或较小数字。

- 计算机内部运算以浮点数格式进行,方便数字运算。

### 浮点数缺点

- 浮点数不是确切的实数,与定点数差异可能导致精度误差。

- 浮点计算可能产生四舍五入误差。

- 浮点运算不满足互Inverse性,如a+b可能不等于b+a。

### 精度问题

- 尾数位数限制造成近似表达。

- 相邻浮点数之间间隔庞大,无法精确表达小数。

-  additions/subtractions更易发生精度损失

### 特殊值

- 含特殊值的运算结果较难预测,如NaN、无限大等。

### 总结

浮点数采用科学计数法表示法更灵活,但与定点数不同,会产生一定的精度误差。在数值计算中需要谨慎选择数据类型并了解其性质。

## 27. [CS61C FA20] Lecture 07.1 - RISC-V Introduction: RISC-V Assembly Language

### RISC-V指令集

- RISC-V是开源的轻量级指令集架构,广泛用于微控制器和系统设计教学。

- 指令采用固定长度(32bit)并且操作数与操作符完全分离。

### RISC-V寄存器

- x0-x31为通用用途寄存器x,x0为硬编码常量0。

- ra是调用者保存寄存器,callee调用返回地址。

- sp为栈指针寄存器。

### RISC-V汇编语法

- 操作码 opcode 操作符 operand,如add x1,x2,x3。

- ri掩码相关寄存器,立即数使用I-type空间。

- 加载 store 使用I-type,移位逻辑使用R-type。

- 注释使用#开头,每条指令单独一行。

视频概览介绍RISC-V指令集特点及汇编语法基础,为学习RISC-V计算机组成奠定基础。

## 28. [CS61C FA20] Lecture 07.2 - RISC-V Introduction: Elements of Architecture: Registers

### RISC-V寄存器

- RISC-V有32个32位宽度的通用寄存器,编号从x0到x31。

- x0专门设定为零,其值不可修改。

- 寄存器命名采用物理命名(x0~x31)和逻辑命名。

### 与变量不同

- 寄存器无类型,执行操作决定其含义。

- 操作数直接为寄存器,而非变量名。

### 注释

- 使用#表示注释,#后内容会被编译器忽略。

- 不支持多行注释,只能单独每行使用#注释。

### 计算机模型

- 处理器通过发出地址从内存读取数据或写入数据。

- 内存模型包含处理器、内存和I/O。

### 总结

RISC-V体系结构核心寄存器特性介绍,阐明与变量的区别,注重指出寄存器在汇编语言中是直接参与运算的运算对象。

## 29. [CS61C FA20] Lecture 07.3 - RISC-V Introduction: RISC-V add/sub Instructions

### RISC-V指令格式

RISC-V指令都遵循统一的格式:操作码、操作数1、操作数2、操作数3。

### 加法指令

加法指令add,格式为:add 操作数1,操作数2,操作数3。

其中操作数1为目标寄存器,操作数2和操作数3为运作数,计算操作数2+操作数3,结果存储在操作数1中。

### 减法指令

减法指令sub,格式为:sub 操作数1,操作数2,操作数3。

计算操作数2-操作数3,结果存储在操作数1中。

### 多操作数运算

如果操作数超过可用寄存器,需要使用中间临时寄存器循环累加/减法进行计算。

视频介绍RISC-V中的加减法基本指令格式,以及利用中间寄存器进行多操作数运算的方法。

## 30. [CS61C FA20] Lecture 07.4 - RISC-V Introduction: RISC-V Immediates

### 立即数

立即数(Immediates)是汇编语言中的数字常量。

### addi指令

addi指令用于将立即数加到寄存器内容中,格式为:addi 目标寄存器,源寄存器,立即数。

### 没有subi指令

RISC-V没有subi指令,因为可以使用addi指令实现,将负数作为立即数传入。

### x0寄存器

x0寄存器内容永远为0,其值不可修改。addi指令使用x0作为源寄存器相当于直接将立即数移动至目标寄存器。

### 用法注意事项

不能使用x0作为目标寄存器,因为其内容无法改变。常见的立即数为0。

视频介绍了RISC-V中的立即数概念,以及addi指令的格式和使用方法。还介绍了x0寄存器的固定值特性。

## 31. [CS61C FA20] Weekly Lecture 04.LIVE - RISC-V

### 寄存器组织

RISC-V共有32个32位宽度的通用寄存器,编号从x0到x31。

- x0内容固定为0,其值不能修改。

- 其他寄存器使用物理寄存器编号(x1-x31)或逻辑寄存器名称。

### 指令格式

RISC-V指令都符合统一格式:操作码 操作数1 操作数2 操作数3

### 常用指令

- add指令:加法,格式为add 操作数1,操作数2,操作数3

- sub指令:减法,格式为sub 操作数1,操作数2,操作数3

- addi指令:立即数加法,格式为addi 操作数1,操作数2,立即数

### 多操作数运算

如果操作数超过可用寄存器,需要使用中间临时寄存器循环执行指令,累计或累减计算结果。

视频介绍了RISC-V体系结构的基本概念,如寄存器组织和常用指令格式。并解释多操作数运算的方法。

## 32. [CS61C FA20] Lecture 08.1 - RISC-V lw, sw, Decisions I: Storing in Memory

### RISC-V中的存储器操作

RISC-V中使用指针访问存储器,有两条关键指令用于加载和存储数据:

- lw指令:加载word,将内存中的值载入寄存器。格式:lw 寄存器,偏移量(立即数)
- sw指令:存储word,将寄存器中的值存储到内存。格式:sw 寄存器,偏移量(立即数)

### 偏移量

偏移量的计算方式为:基地址 + 偏移量常数。基地址通常存放在某个寄存器中。

### 存储器访问原理

1. 通过lw指令将内存值载入寄存器
2. 使用计算或逻辑指令操作寄存器中的值
3. 通过sw指令将结果存回内存

### 多条指令实现读写

由于RISC-V只支持三操作数指令,当需要对内存进行连续读写时,需要用多条指令实现。

视频介绍了RISC-V中存储器读写的两个核心指令lw和sw,以及存储器地址计算方法和多条指令访问存储器的实现机制。

## 33. [CS61C FA20] Lecture 08.2 - RISC-V lw, sw, Decisions I: Data Transfer Instructions

### 数据传输指令

RISC-V中负责数据传输的主要指令有:

- lw(load word):从内存加载32位数据到指定寄存器
- sw(store word):从指定寄存器存储32位数据到内存

### 指令格式

lw和sw指令采用I格式:

- opcode为加载或存储操作
- 寄存器1表示存储器操作的数据目标或源
- 寄存器2为基址寄存器
- I类型字段为立即偏移量

### 基址寻址

基址寻址方式:

- 寄存器2内容作为基地址
- 加上I类型字段中的立即偏移量
- 得到最终内存地址

### 数据传输原理

1. 计算加载/存储地址
2. processor通过地址访问内存
3. 实现数据从内存和寄存器之间的传输

视频详细分析了RISC-V的lw和sw指令格式以及基于寄存器的内存寻址机制。

## 34. [CS61C FA20] Lecture 08.3 - RISC-V lw, sw, Decisions I: Decision Making

### 决策指令

RISC-V中有三个常用的决策(条件)指令:

- beq指令:如果相等则跳转
- bne指令:如果不相等则跳转  
- blt指令:如果小于则跳转

### 指令格式

决策指令采用SB格式:

- opcode为决策操作码
- 寄存器1为第一个操作数
- 寄存器2为第二个操作数
- SB类型字段为目标地址的偏移量

### 决策流程

1.比较操作数1和操作数2

2.如果满足条件(相等/不相等/小于),则计算跳转目标地址

3.根据比较结果,决定是否跳转

4.如果跳转,则使用计算的目标地址

### 实现分支结构

通过有条件的跳转指令实现分支和循环流程控制。

视频介绍了RISC-V三类常用判断指令的格式和工作原理,以及如何利用这些指令实现程序流程控制。

## 35. [CS61C FA20] Lecture 09.1 - RISC-V Decisions II: Logical Instructions

### 逻辑指令类型

RISC-V汇编中包含按位与、或、异或以及移位指令。

### 指令格式

逻辑指令包括操作寄存器的版本和立即数版本。

### 指令示例

- and指令:将寄存器x6和x7按位与,结果输出到x5。
- andi指令:将寄存器x6和立即数三按位与,结果输出到x5。

### 移位指令

- sll指令:将寄存器x12左移两位,结果输出到x11。
- slli指令:将寄存器右移指定位数,填充0。

### 移位特点

左移相当于乘以2的幂次方,右移相当于除以2的幂次方。可通过移位实现乘除运算。

视频介绍了RISC-V汇编中的逻辑指令格式分类,并给出了与、与、移位指令的示例,阐述了移位指令实现乘除的原理。

## 36. [CS61C FA20] Lecture 09.2 - RISC-V Decisions II: A Bit About Machine Program

### 汇编程序执行流程

编写的汇编源文件(.s)通过汇编器转为对象文件(.o),再通过连接器链接成可执行程序(.out)。

### 对象文件和库文件

对象文件包含机器码和调试信息。库文件提供常用函数实现。连接器将它们链接成一个可执行程序。

### 程序存储区

可执行程序存放在内存代码段,数据段存储数据。两个段分开设置,避免数据覆盖代码造成异常。

### 程序执行

处理器中的程序计数器持有下一条指令地址。控制单元根据它取指令,数据路径执行,更新程序计数器指向下一条指令。

### 寄存器命名

RISC-V有32个通用寄存器,采用物理和符号命名方式,方便记忆寄存器用途。

### 伪指令

定义一些常用操作的指令别名,如move表示复制注册的值,方便编写和阅读程序。

视频主要介绍了机器代码程序的组成、存储和运行过程,以及RISC-V体系结构中的一些实用概念,如寄存器命名和伪指令定义。

## 37. [CS61C FA20] Lecture 09.3 - RISC-V Decisions II: RISC-V Function Calls

### 函数调用的基本步骤

1.将参数值存入函数可以访问的位置

2.转移控制至函数体

3.获取函数执行需要的本地内存资源

4.执行函数任务

5.将返回值放入调用位置可以访问的位置

6.还原任何寄存器到调用前状态

7.释放本地内存资源

8.返回至原调用位置

### RISC-V函数调用惯例

使用a0-a7寄存器传递最大8个参数,a0-a1寄存器返回值

使用x1(ra)寄存器传递返回地址

s0-s11寄存器传递保护寄存器值

### 函数调用汇编实现

将参数传至a0-a1,返回地址放入ra,调用jwl指令跳转至函数

函数内执行操作,将结果放入a0-a1,使用ret指令跳转回调用位置

ret指令用jr ra实现,将ra中的返回地址 LOAD到pc寄存器

jwl指令实现跳转+链接返回地址,更高效地支持函数调用

视频详细介绍了RISC-V函数调用的汇编实现步骤、函数参数传递方式以及重要指令支持。

## 38. [CS61C FA20] Lecture 10.1 - RISC-V Procedures: Function Call Example

### 函数调用基本步骤

1. 主程序将参数值存入函数可以访问的位置

2. 转移控制至函数体

3. 函数获取本地内存资源

4. 执行函数任务

5. 将返回值放入调用位置可以访问的位置

6. 恢复任何寄存器至调用前状态

7. 释放本地内存资源

8. 返回至原调用位置

### RISC-V函数调用惯例

使用a0-a7寄存器传递最大8个参数,a0-a1寄存器返回值

使用x1(ra)寄存器传递返回地址

s0-s11寄存器传递保护寄存器值

### 函数调用汇编实现

将参数传至a0-a1,返回地址放入ra,调用jwl指令跳转至函数

函数内执行操作,将结果放入a0-a1,使用ret指令跳转回调用位置

### 具体例子

例子为函数leaf,有4个参数g,h,i,j;返回一个值f

参数通过a0-a3传递,结果通过a0返回

需要使用s0-s1临时寄存器

首先为s0-s1在栈中开辟空间,然后执行加法赋值操作

最后恢复s0-s1,释放栈帧空间,并通过ra返回

## 39. [CS61C FA20] Lecture 10.2 - RISC-V Procedures: Register Conventions

RISC-V函数调用采用注册约定,区分保存寄存器和临时寄存器。

保存寄存器包括栈指针sp和s0-s11寄存器。它们的值在函数调用间保持不变。

临时寄存器包括返回地址寄存器ra和参数传递寄存器a0-a7。它们的值在函数调用间不保证。

调用者需要保存自己在临时寄存器中的值,以便函数调用后恢复。被调用函数需要保存和恢复保存寄存器中的值。

视频详细介绍了RISC-V函数

## 40. [CS61C FA20] Lecture 10.3 - RISC-V Procedures: Memory Allocation

### 函数调用基本步骤

1. 主程序将参数值存入函数可以访问的位置

2. 转移控制至函数体

3. 函数获取本地内存资源

4. 执行函数任务

5. 将返回值放入调用位置可以访问的位置

6. 恢复任何寄存器至调用前状态

7. 释放本地内存资源

8. 返回至原调用位置

### 函数调用使用栈存储本地变量

函数的栈帧包含返回地址、保存的寄存器值和本地变量。

### RISC-V下不同内存区域分布

栈存储从高地址向低地址增长。

堆存储从低地址向高地址增长。

静态区域存储在程序代码与数据之间。

程序代码存储在低地址端。

### 嵌套函数调用示例

sum_square函数调用mult函数,需要保存返回地址和参数y值,增加栈指针长度。

调用mult函数后,恢复y值和返回地址,执行余下指令,返回调用位置。

### C语言各内存区域对应RISC-V

栈存储函数调用本地变量。

堆存储malloc申请的内存。

静态存储区域存储全局变量和静态局部变量。

程序代码存储函数代码定义。

视频详细说明了RISC-V下不同内存区域的布局,以及通过示例阐述了嵌套函数调用时栈管理细节。

## 41. [CS61C FA20] Lecture 10.4 - RISC-V Procedures: Summary

### 函数调用基本步骤

1. 主程序将参数传给函数

2. 转移控制到函数体

3. 函数获取本地内存资源

4. 执行任务

5. 将返回值传回主程序

6. 恢复任何寄存器与内存状态

7. 释放本地资源

8. 返回主程序

### RISC-V调用惯例

使用a0-a7传参,a0-a1传返值

使用ra传返回地址

s0-s11传保存寄存器值

### 内存区域

栈从高到低增长存储临时变量

堆从低到高增长存储malloc空间

静态区放全局变量和静态局部变量

代码区放函数定义

视频总结了RISC-V函数调用各个环节,参数传递方式,栈堆区分布情况,为学习RISC-V汇编奠定基础。

## 42. [CS61C FA20] Weekly Lecture 05.LIVE - RISC-V & CALL

### RISC-V汇编指令分类

可以从机器执行逻辑分组:

- 寄存器操作指令
- 加载和存储指令  
- 判断和分支指令
- 调用和返回指令

### 寄存器操作指令

如算术、逻辑指令

### 加载和存储指令

如lw和sw,负责数据传输

### 判断和分支指令

如beq,bne,实现条件分支

### 调用和返回指令

如jal,jalr实现函数调用

### RISC-V函数调用惯例

使用a0-a7传参,a0-a1传返回值

ra传递返回地址

s0-s11传保护寄存器值

### 调用过程

设置参数与返回地址,jal跳转调用,ret返回

### 示例代码

sum函数实现两个整数相加,通过调用传参实现

视频通过RISC-V汇编示例分析函数调用过程,并总结了RISC-V函数调用惯例。

## 43. [CS61C FA20] Lecture 11.1 - RISC-V Instruction Formats I: Intro

### 指令格式

RISC-V支持3种基本指令格式:

- R型指令:寄存器操作指令
- I型指令:加载/存储指令
- S/B型指令:系统/分支指令

### R型指令格式

opcode为寄存器操作码

rs1、rs2、rd分别表示操作数1、2和结果寄存器

### I型指令格式

opcode为加载/存储操作码

rs1表示基址寄存器

imm[11:0]表示12位无符号立即数偏移量

### S/B型指令格式

opcode为系统/分支操作码

rs1表示操作数1寄存器

imm[11:0]表示12位有符号偏移量

### 指令字长

所有RISC-V指令均为32位长度

### 指令解码

处理器根据opcode解码指令类型和操作

提取各字段寄存器号与立即数

执行相应的算术/逻辑/内存操作

视频介绍了RISC-V三种主要指令格式的组成和含义,为学习RISC-V汇编奠定基础。

## 44. [CS61C FA20] Lecture 11.2 - RISC-V Instruction Formats I: R-Format Layout

### R格式指令布局

RISC-V指令长度为32位, R格式指令按固定格式划分字段。

低7位是操作码,其中所有R格式指令操作码为`0110011`。

后5位为目标寄存器rd,代表指令结果存入的寄存器。

中间3位为func3,不同指令通过它来区分。

再后5位和5位分别为源操作数寄存器rs1和rs2。

最后7位是func7,与func3一起完全区分指令种类。

### R格式指令编码示例

以add x18, x19, x10为例:

- 操作码为0110011
- rd为x18,二进制编码100010  
- func3和func7字段add指令全为0
- rs1为x19,二进制编码100011
- rs2为x10,二进制编码001010

最后编码为040093e3。

### R格式指令分类

R格式指令包括add、sub、sll、slt、xor、srl、sra等算数逻辑指令。它们操作码和寄存器位置相同,通过func3和func7来区分。如add和sub通过func3低位区别,实现相同的加法逻辑。

此外,func3和func7未完全利用,保留扩展性。指令编码带来的冗余可帮助CPU识别指令。

## 45. [CS61C FA20] Lecture 11.3 - RISC-V Instruction Formats I: I-Format Layout

### I类型指令格式

I类型指令支持立即数操作,通过加入12位立即数字段实现。

### 格式结构

和R类型一样,低7位为操作码。

后5位为目的寄存器rd,中间3位为func3字段。

 repurpose rs2位置为12位立即数imm[11:0]字段。

加入func7字段扩充立即数范围。

### 支持指令

共9条I类型指令:ADD、XOR等7条与R类型相同,新增SLTI、SLTIU。

### 编码示例

addi x15 x1 -50,将x1值与-50相加后存储于x15。

opcode为0 0 1 0 0 1,rd为15,rs1为1,func3与R类型相同,imm为-50的二进制补码。

### 立即数范围

imm为12位,范围为-2048~2047,执行时自动扩充为32位有符号数。

 shifted amount限于5位,func7位编码右移算术/逻辑模式。

视频详细解析了RISC-V I类型指令格式设计及其支持指令集合。

## 46. [CS61C FA20] Lecture 11.4 - RISC-V Instruction Formats I: Loads

### RISC-V支持的读指令

有多条load指令,但都属于同一类型,即I格式。

### I格式布局

与R格式相同,操作码7位,低5位为目的寄存器,中间3位func3,高5位为源寄存器。

将R型源寄存器2位置替换为12位有符号不变值。

### load指令操作

将源寄存器加外部立即数得到内存地址,从内存读入值到目的寄存器。

### load类型

根据数据长度有load byte、halfword、word指令。

还有unsigned版本避免补码处理。

### 示例

lw x14, 8(x2)
将x2+8地址内容读入x14,操作码11结合func3区分类型。

### 细节

字/半字自动在低位填充并进行补数扩充,unsigned版本跳过此步。

RISC-V利用现有I格式支持读指令,func3区分具体操作类型。

## 47. [CS61C FA20] Lecture 11.5 - RISC-V Instruction Formats I: S-Format

### 存储指令格式

存储指令需要两个源寄存器,与R格式相似,但无目的寄存器。

### S格式

操作码7位,后5-5位分别编码两个源寄存器rs1、rs2。

二者功能不同,rs1指示基址,rs2指数据源。

 immediate值分成上7位和下5位,组成12位有符号值。

### 示例

sw x14,8(x4)

将x14内容存储到x4+8地址。

opcode为01000,rs1为x4,rs2为x14,imm为8。

### 存储类型

byte、halfword、word三种,分别存储不同位数数据。

### 注意点

保持寄存器位置不变,提高识别效率。

immediate拆分编码避免修改现有格式。

S格式与R格式类似但省去目的寄存器,适用于存储指令。

## 48. [CS61C FA20] Lecture 12.1 - RISC-V Instruction Formats II: B-Format

### 分支指令格式

RISC-V指令集中加入直接分支和条件分支指令。

### B格式

操作码7位。后11位为有符号立即分支偏移量。偏移量乘以4字节。

分支目标地址计算为:PC + (imm << 2)

### 示例

b addr 直接跳转到addr地址。

opcode为11000,imm为addr在代码中的相对位置。

### 条件分支

带条件码运算结果的分支。

标志位由算数逻辑指令设置。

通过func3字段来区分分支类型。

### B tipo分类

BEQ/BNE - 等于/不等于0条件分支

BLT/BGE - 小于/大于等于条件分支

RISC-V在现有B格式上支持直接和条件分支指令,通过Imm和Func3区分型号。大大增加程序流控制能力。

## 49. [CS61C FA20] Lecture 12.2 - RISC-V Instruction Formats II: Upper Immediates

在此之前,我们已经介绍了RISC-V指令集里I格式,R格式和布尔逻辑格式指令。这些指令都将立即数编码在指令本身里,但是立即数只有12bit。

有时我们需要表达比12bit更长的立即数,RISC-V提供了U格式指令来解决这个问题。U格式指令使用指令本身的高位位来编码20bit的上置立即数。

具体来说,U格式指令包括两个:

- LUI(Load Upper Immediate):加载上置立即数到目标寄存器的高20位,低12位清零。

- AUIPC(Add Upper Immediate to PC):将上置立即数添加到程序计数器值,结果存储在目标寄存器。

U格式指令使用指令码最低7bit标识指令,使用两个不同的OPCODE区分LUI和AUIPC。

利用LUI和I格式指令加法,可以实现32bit立即数加载到寄存器的目的。

但是直接这样操作会导致大小端问题。因为I格式加法指令会符号扩展立即数最高位,处理负数时会出现错误。

正确的方式是,对需要表达的32bit立即数,提前加1,然后利用LUI+加法加载到寄存器。RISC-V也提供了Li伪指令来帮助完成这个过程。

AUIPC指令很有用,可以为分支指令提供长距离目标地址。此外,它还可以直接获取当前程序计数器的值,这对函数返回地址很有帮助。

以上就是RISC-V用来支持长距离立即数的U格式指令的介绍。它解决了之前I格式和R格式指令立即数范围限制的问题。

## 50. [CS61C FA20] Lecture 12.3 - RISC-V Instruction Formats II: J-Format

### RISC-V指令集中的J格式

J格式指令专门用于控制跳转指令jal和jalr。

### jal指令格式

操作码7位,目的寄存器rd 5位,上半部分20位跳转偏移量mid。

### jal指令功能

将当前pc+4保存到目的寄存器rd,即返回地址。将程序计数器设置为pc+mid。

mid为有符号整数,乘2字节得实际跳转量。仅跳转偶地址有效指令。

### jalr指令格式

操作码7位,目的寄存器rd 5位,源寄存器rs1 5位,下半部分12位立即数imm。

### jalr指令功能

同jal,但pc计算为rs1+imm,可以实现任意地址跳转。imm为有符号整数。

### 优化考虑

jal忽略最低1bit实现跳转偶地址。jalr实际范围由12bit定义。

可以通过加载地址到寄存器,实现jalr的相对跳转。

J格式实现了RISC-V中功能完整的跳转指令集,支持函数调用与任意跳转。

## 51. [CS61C FA20] Lecture 12.4 - RISC-V Instruction Formats II: Summary

### RISC-V指令格式概述

RISC-V指令集包括I型指令、S型指令、B型指令、U型指令、J型指令、以及用于环境调用和操作系统支持的特殊指令。

### 指令编码原则

为了简化硬件设计,保证寄存器和立即数总在固定位置出现。这些优化虽增加了理解难度,但提高了处理器运行效率。

### RISC-V版本更新

RISC-V指令集交流版本已十年不断完善,其基础集和部分扩展指令于近期获得正式标准认证。

### C程序可靠性

经过优化的RISC-V指令格式,可以支持任意C程序通过编译、汇编、链接和加载运行。这为从C到汇编再到计算机体系结构的学习奠定基础。

### 后期内容展望

理解完RISC-V指令集后,将进一步学习汇编器、链接器和加载器的工作原理,以及真实处理器硬件的设计实现RISC-V指令的执行。

## 52. [CS61C FA20] Lecture 13.1 - Compilation, Assembly, Linking, Loading: Interpretation vs Translation

### 解释与翻译

程序有两种执行方式:

1. 解释执行:程序每行解释运行。

2. 翻译执行:整个程序先翻译成机器语言,再直接由CPU执行。

### 编译器工作原理

编译器接受源程序,分析语法和语义,生成目标代码。目标代码可以是汇编或机器代码。

### 汇编、链接和加载

- 汇编器将汇编代码转换成机器语言对象代码。

- 链接器将多个对象文件连接成一个执行文件。

- 加载器将执行文件加载到内存中,CPU可直接运行。

### 优缺点对比

解释执行令程序 portable,但效率低;翻译执行效率高,但限于特定平台。

编译器将高级语言程序翻译成能由硬件直接执行的机器代码,实现高效运行。

## 53. [CS61C FA20] Lecture 13.2 - Compilation, Assembly, Linking, Loading: Compiler

### 编译器工作流程

编译器从C代码作为输入,输出汇编语言文件(.s文件)。通过gcc命令加上-s参数可以单独生成.s文件。

### 编译生成中间文件

编译器对源码进行词法、语法和语义分析,并生成目标代码文件(.s文件)。.s文件可以通过手写,也可以通过编译C代码自动生成。

### 汇编语言文件

.s文件中的指令遵循RISC-V汇编格式。为简化编写,允许使用伪指令,如move指令模拟数据拷贝操作。

### 优化选项

开启优化选项可以改变编译结果。也可以手动编写.s文件来实现特定效果。

### 实践编码

理解RISC-V汇编语法,通过Venus环境手码和编译小型C程序二进制码,能熟练掌握编译流程。

### 总结

编译器将高级语言代码转换为专用于特定平台的机器语言,实现跨平台编程。中间文件.s文件包含RISC-V汇编指令及伪指令,为后续汇编、链接、加载提供输入。

## 54. [CS61C FA20] Lecture 13.3 - Compilation, Assembly, Linking, Loading: Assembler

### 装配器作用

汇编可执行文件(.o文件)将汇编语言(.s文件)翻译成机器语言指令,为链接提供输入。

### 汇编过程

解析汇编指令,将操作码、寄存器编号和立即数翻译成机器语言指令的二进制码。识别伪指令并转换成实际指令。

### 输出文件

产生对象文件(.o文件),包含代码部分、数据部分和符号表。符号表记录外部变量和函数,为后续链接提供参考。

### 链接需要的信息

符号表中的信息将在链接阶段使用,如函数地址、变量地址等。符号表还记录源文件名和行号,方便调试。

### 补充知识

汇编也可以针对C代码自动生成,不一定由人手写汇编代码。优化选项也可能影响汇编结果。

### 总结

汇编器翻译汇编语言到机器语言,产生目标文件作为链接的输入。它保留链接需要的符号表信息,同时移除抽象层次的伪指令,实现真正的机器级执行语言。

## 55. [CS61C FA20] Lecture 13.4 - Compilation, Assembly, Linking, Loading: Linker

### 链接器作用

链接器连接对象文件(.o文件)成为可执行程序,解决多个.o文件中符号重复定义的问题。

### 链接过程

1. 对象文件中提取符号表信息。

2. 分析匹配符号,解决多定义符合问题。

3. 合并代码和数据段,生成单一地址空间。

4. 生成可执行文件或库文件。

### 库文件

链接时可以引入静态库(.a文件)或动态库(.so文件)来重用代码。这些库中可能包含独立模块。

### 链接指令

Linux链接器ld通过脚本配置链接行为。链接时需要表达模块的加载地址、搜索路径等信息。

### 调试链接

使用map文件查看symbols合并情况,查看重复定义及引用错误。ld也支持一些调试选项进行分析。

### 总结

链接器将相关对象结合库文件合成一个可执行文件,实现模块与模块之间的连接,解决变量定义重复的问题。它隐蔽了模块间的交互实现细节。

## 56. [CS61C FA20] Lecture 13.5 - Compilation, Assembly, Linking, Loading: Loader

加载器的工作是将可执行程序加载到内存中运行。

加载器首先通过程序头文件获取代码和数据段的大小信息。然后为程序分配地址空间,给文本、数据和栈留出足够的空间。

将程序的二进制代码和数据从磁盘复制到分配的内存空间。

如果程序有命令行参数,也将它们复制到栈中。

设置初值寄存器状态,清空非系统寄存器。初始化栈指针指向空栈位置。

将程序参数从栈复制到对应寄存器,如 argc 和 argv。设置内存中的入口点指针 pc 指向 main 函数起始位置。

启动程序后,根据返回码将结果返给操作系统。操作系统负责程序正确终止后释放资源。

加载器的主要作用是将离线的可执行代码加载到内存并运行,它隐藏了操作系统的具体实现细节。

## 57. [CS61C FA20] Lecture 13.6 - Compilation, Assembly, Linking, Loading: Example

### 举例说明编译、汇编、链接和加载整个流程

#### 编写和编译小型C程序

编写hello world程序,使用gcc编译生成汇编代码文件hello.s。

#### 汇编程序

使用assembler将汇编代码翻译成对象文件hello.o。

#### 链接

使用ld链接器将标准库连接到hello.o,生成可执行文件a.out。

#### 使用反汇编查看

使用objdump反汇编a.out,查看汇编指令。

#### 加载并运行

使用命令./a.out在Venus上加载并运行可执行文件,打印输出。

#### 总结各个阶段

摘要介绍编译、汇编、链接和加载过程,说明它们如何将高级语言程序转换并运行在计算机上。

本例从源代码开始,全程跟踪一个“hello world”程序经历的各个阶段,帮助理解整个从C到执行的转化过程。

## 58. [CS61C FA20] Weekly Lecture 06.LIVE - SDS & CL

### 内存布局模型

- 分段模型(Segment Model):segment内存是连续的,但segment之间不一定连续。

- 共享段模型(Shared Segment Model):segment可被多个进程共享。

- 页式模型(Page Model):内存划分为固定大小的页面,节省空余内存。

### 页表

- 页表存储了虚拟地址到相应物理页的映射关系。

- 多级页表可以管理更多虚拟地址空间。RISC-V支持39位虚拟地址。

- TLB缓存部分页表项,提升查询效率。但缺页中断也需要从高速缓存查找相关页表。

### 内存管理单元(MMU)

- MMU负责虚拟至物理地址转换,实现存储管理功能,通过许可位控制存储允许的读写权限。

- MMU包含TLB和页表寄存器,实现地址转换与权限检查。

### 共享存储器

- 使用共享存储实现进程间资源共享有效提升内存利用率。

- 内核提供友好的共享接口,实现并发访问同步和安全。常用技术如信号量、互斥锁等。

### 总结

内存管理实现了进程隔离和共享,是操作系统的核心内容。共享存储器和高速缓存技术提升了系统性能和资源利用率。

## 59. [CS61C FA20] Lecture 14.1 - Intro to Synchronous Digital Systems: Switches

### 电平开关

电平开关有两种状态:0电平和1电平,由低电压和高电压表示。

### 三态逻辑开关

三态逻辑开关有三种状态:0、1和高阻断态Z。Z态电阻极大,电路中开关不参与传输。

### 逻辑门

通过组合开关实现逻辑运算功能,如与门、或门等基础逻辑门。

### 组合电路

将不同逻辑门连接形成更复杂的功能,但输出不依赖于时间,即输入改变立即产生输出。

### 时序电路

添加时钟信号后,电路在每个时钟脉冲上同步产生输出,输出与输入在不同时钟之间有延迟。

### 时钟周期

时钟周期决定电路操作速度。一个时钟周期内,电路读取输入,进行计算,产生输出。

### 总线

总线用于传输输入和输出数据,常用的数字设备总线有地址总线和数据总线。

理解电平开关和基础电路组合是学习数字系统的基础。时钟增加了时序属性,决定了数字系统的速度。

## 60. [CS61C FA20] Lecture 14.2 - Intro to Synchronous Digital Systems: Transistors

### 导体

导体内电子可自由移动,电流可随电位差流动。

### 半导体

半导体掺杂不同浓度给体添入杂质形成P区和N区,具有导电和绝缘的双面属性。

### PN结

P区和N区接触形成PN结,是最基本的半导体器件。当正负极提供电势后可控制通过或阻断电流。

### 晶体管

通过控制栅极电场改变沟道电阻,实现开通或截止电流的三极管。N型场效应管和P型场效应管构成CMOS技术的基础。

### CMOS技术

组合N型和P型MOSFET形成基本逻辑门,两种类型互补操作大幅降低功耗。成为现代电路的主流技术。

### 寄存器转移级

多级反相器串联可实现时钟边缘触发输出翻转,产生定时控制脉冲的功能。

半导体物理基础提供了控制电流的晶体管,CMOS电路利用其低功耗优势构建数字逻辑器路。时钟生成使它们具备同步属性。

## 61. [CS61C FA20] Lecture 14.3 - Intro to Synchronous Digital Systems: Signals and Waveforms

### 数字信号

数字信号只有两个电平,以不同电平表示0和1。

### 模拟波形

实际物理电压或电流随时间变化的连续函数曲线。

### 数字波形

数字逻辑以标准模拟电压表示0和1电平的数字信号。

### 方波

周期性上下翻转 zwischen两个电平的矩形波,如时钟信号。

### 时间标识

升沿定义为0-1转换点,降沿定义为1-0转换点。

### 时钟频率

时钟一个周期内0-1-0转换次数,以赫兹(Hz)计量。高频时钟可实现高速运算。

### 采样时间

时钟脉冲中定义了数字系统评估输入和产生输出的时间点。

### 波形图示

图示信号随时间的模拟波形,观察数字信号的变化趋势。

理解数字和模拟信号的差异,以及时钟在同步系统中的重要性,是数字逻辑系统设计的基础。

## 62. [CS61C FA20] Lecture 15.1 - State, State Machines: Accumulator

### 介绍状态电路

状态电路能记住值,常用于寄存器和存储器。它们可以控制组合电路之间的信息流转。

### 尝试不用状态电路构建累加器

直接使用组合加法器无法连续完成累加操作,因为无法控制迭代和初始化值。

### 使用状态寄存器

引入状态寄存器后,可以通过重置线初始化值,通过加载线控制每次迭代。输出将前一步结果反馈至输入,实现连续累加。

### 时序示意

输入数采样于时钟上升沿,状态寄存器在每个时钟边缘更新值。累加过程顺序为:reset->x0->x0+x1->x0+x1+x2->...

### 总结

直接使用组合电路无法完成累加操作。状态电路可以通过初始化和迭代控制,将组合电路应用于连续运算,实现累加器功能。

## 63. [CS61C FA20] Lecture 15.2 - State, State Machines: Register Details Flip-flops

### 芯片内部的寄存器

寄存器内部由多个并联的基础存储单元组成,称为“触发器”。

### 触发器

触发器可以记住一个位的数字状态,输出当前输入值或保持上一个值。主要有D触发器。

### D触发器工作原理

D触发器采样数据线D的值,在时钟上升沿时将D值存储到输出Q。之后即使D值变化,Q也保持不变,除非下次时钟上升沿。

### 寄存器示意图

n位寄存器内部由n个并联的1位D触发器组成,数据线输入联通,时钟信号也联通并驱动所有触发器。

### 时序图示例

示例说明不同时钟沿D和Q的变化过程:时钟上升沿触发器采样D,Q输出延迟一段时间后稳定;期间D可以变化但Q保持不变。

### 触发器规格参数

重要参数包括设置时间、保持时间和触发到输出延迟时间。这些参数决定了触发器的工作频率及设计复杂程度。

理解触发器工作原理可以帮助设计利用时钟同步的数字逻辑电路。触发器参数关系到电路性能及成本。

## 64. [CS61C FA20] Lecture 15.3 - State, State Machines: Accumulator revisited

### 加法器的状态机实现

前面学习过如何用单个D触发器实现加法器,现在使用状态机的方式讲解。

### 状态表

定义加法器有4个状态:S0代表当前总和为0,S1代表总和为1,以此类推直到S3代表总和为3。

### 状态转换表

根据状态和两数位输入,定义下一个状态。例如状态S1和输入"01",下个状态为S2。

### 硬件实现

使用2个D触发器分别代表状态位和输出总和。状态转换依据状态表,输出依据状态决定。时钟驱动触发器同步工作。

### 状态机波形示意图

示例如何在不同时钟沿根据状态表和输入,实现状态和输出的变化。

### 与单触发器实现比较

与单触发器实现相比,状态机实现利用状态更清晰表达逻辑,但需要更多硬件资源来表示和控制状态。

理解状态机思想可以帮助设计复杂的数字 logic 电路。适当选择单触发器或状态机实现,取决于具体应用中对性能和成本的要求。

## 65. [CS61C FA20] Lecture 15.4 - State, State Machines: Pipelining for Performance

### 性能提升方法

通过管路技术提升系统性能。

### 频率限制因素

电路总时延必须小于时钟周期,时钟频率上限由时钟到Q延迟、组合逻辑延迟和设置时间决定。

### 管线处理

在逻辑路径中插入寄存器,将大型组合逻辑分解为多个较小阶段。每个阶段执行独立任务。

### 管线定时图

说明每个阶段的输入输出关系和时序限制。

### 优点

对单个数据来说延迟可能增加,但吞吐量大幅提高,单位时间内产生的输出更多。

### 应用案例

利用两个工人分解复杂任务性能更高。最大时延由各阶段延迟的和决定时钟频率。

### 关键参数

时钟频率、时钟到Q延迟、设置时间、组合逻辑延迟与保持时间关系。理解这些参数能设计高性能数字电路。

## 67. [CS61C FA20] Lecture 16.1 - Combinational Logic: Truth Tables

### 组合逻辑

 输出仅取决于输入,不依赖时钟。

### 真值表

记录所有可能输入组合及对应的输出值。

### 逻辑运算符

与、或、非等基本逻辑运算。

### 真值表步骤

1. 确定输入变量名和个数

2. 记录所有可能的输入组合

3. 根据逻辑表达式计算每个输入组合对应的输出

### 示例

如A或B的真值表:

|A|B|A或B|
|-|-|-|
|0|0|0|
|0|1|1|
|1|0|1|
|1|1|1|

真值表分析逻辑表达式,是理解逻辑门和电路的基础。

## 68. [CS61C FA20] Lecture 16.2 - Combinational Logic: Logic Gates

### 逻辑门

实现特定逻辑功能的组合电路。

### 主要逻辑门

1. 与门:当所有输入为1时输出为1。

2. 或门:当任一输入为1时输出为1。  

3. 非门:将输入值取反。

4. 异或门:当输入不同时输出为1。

### 门符号

每个逻辑门都有对应的电路符号,以表示输入输出关系。

### 实现方式

利用MOS管或传统方式实现逻辑门模拟电路。也可用编程语言描述逻辑功能。

### 电路特性

与门需要所有输入电平高才导通;或门有任一输入高即导通。非门直接取反。

### 应用

逻辑门是计算机芯片的基础元件,广泛应用于CPU、内存控制等数字电路设计。

理解逻辑门的工作原理和电路表示方法,对设计数字系统很重要。

## 69. [CS61C FA20] Lecture 16.3 - Combinational Logic: Boolean Algebra

### 布尔代数

是用于描述组合逻辑电路的数学框架。它模拟了逻辑门的工作原理。

### 布尔代数操作

1. 加法(或):a+b
2. 乘法(与):ab
3. 取反(非):overline{a}

### 布尔表达式写法

1. +表示或
2. ×表示与
3. 上棱表示非

### 例一

一个多数投票电路的布尔表达式为:
ab + ac + bc

### 例二

状态机表达式中的布尔表达式:
ps1 × not(ps0) × input

### 公式细化

通过利用代数学法则,可以将布尔表达式进一步简化成含最小门数的形态。

### 判断电路等价

利用布尔代数公式化和简化两个不同形式的电路表达式,若最简形式相同,则两电路等价。

布尔代数提供了一套系统的方法描述和优化组合逻辑电路,对数字电路设计具有重要意义。

## 70. [CS61C FA20] Lecture 16.4 - Combinational Logic: Laws of Boolean Algebra

### 布尔代数法则

1. 交换法则: A+B = B+A, AB = BA

2. 结合法则: A+(B+C) = (A+B)+C, A(BC) = (AB)C  

3. 分配法则: A(B+C) = AB + AC

4. 编码法则: A+A=A, AA=A  

5. 二元法则: A+1=1, A·1=A, A+0=A, A·0=0

6. 吸收法则: A+AB = A, A+A'B = 1

7. 消除法则: A+A' = 1, AA'+BB' = A+B

### 法则应用

通过按照上述布尔代数法则,可以对布尔表达式进行变换,最终得到表达式最简形式。

### 示例

(A+B)C = AC + BC   (应用分配法则)

A+A=A                (应用编码法则)

等式变换可以优化逻辑电路,找到性能最佳实现方案。

理解这些布尔代数基本法则对分析和设计数字电路很重要。它们关乎电路简化与优化。

## 71. [CS61C FA20] Lecture 16.5 - Combinational Logic: Canonical Forms

### 规范形式

将逻辑表达式描述为一种标准化的方式,即规范形式。

### 真值表到规范形式

根据真值表中输出为1的情况,得到每个行的布尔表达式,然后求与(与非门)。这被称为求积和。

### 求积和公式

利用布尔等式进行变换,将求积和表达式简化为最简形式。

### 例题求解

给出一个3变量的真值表,通过求积和获得规范表达式,然后利用传配律、互补律等布尔等式进行变换,最终得到最简规范形式。

### 规范形式与门级图的对应关系

将规范表达式对应为与非门的组合,利用通到前推与后推将非门转化为输入或输出处的气泡形式。

### 优势

真值表到规范表达式,再到门级图的转换路径清晰。规范表达式能清晰反应逻辑关系,并且通过简化可以获得最优化的电路实现方案。

理解规范形式可以有效地分析和优化数字电路的结构。它是数字电路设计的重要方法之一。

## 72. [CS61C FA20] Weekly Lecture 07.LIVE - RISC-V Datapath

### RISC-V指令集

RISC-V是一种开源的微处理器指令集体系结构,具有可扩展性。

### 数据通路

数据通路执行指令,包括 registar file(寄存器文件)、ALU、memory等基本模块。

### 指令类型

RISC-V指令包括I型(算术逻辑运算)、S型(存储)、R型(寄存器)、B型(分支跳转)指令等。

### 流水线

利用流水线技术,可以实现同时执行不同阶段的指令,提高吞吐量。

### 寄存器文件

保存寄存器的值。RISC-V中有x0~x31个通用寄存器。

### 控制单元

根据指令opcode产生控制信号,控制数据通路上各组件的工作顺序。

### 数据通路工作原理

在一个时钟周期内,控制单元根据指令完成register读取、ALU运算、memory访问等步骤,执行指令操作。

### 优点

RISC-V简单易用,开源性好,可根据需求扩展指令集,非常适合嵌入式系统和教学目的。

理解RISC-V数据通路机制,有助于学习微处理器设计原理。

## 73. [CS61C FA20] Lecture 17.1 - Combinational Logic Blocks: Data Multiplexors

### 多路选择器

根据选择信号选择其中一个数据输入作为输出,是组合逻辑的基本模块。

### 多路选择器的工作原理

具有多个数据输入端和一个数据输出端,根据条件选择信号选择一个数据输出。

### 2路选择器电路图

以选择信号S=0时选择D0作为输出,S=1时选择D1作为输出。

### 多路选择器电路图

通过层叠2路选择器实现多路选择功能,选择线数等于数据输入端数。

### 多路选择器的真值表

记录各选择条件下对应数据输出的值。

### 求解多路选择器表达式

利用选择条件及数据输入构成布尔表达式描述多路选择器工作。

### 多路选择器在计算机体系结构中的应用

如指令寻址、数据访问控制等,实现选择不同寄存器或内存值。

理解多路选择器的工作原理对学习计算机系统架构及数字电路设计很重要。

## 74. [CS61C FA20] Lecture 17.2 - Combinational Logic Blocks: ALU

### 算术逻辑单元(ALU)

ALU是组合逻辑块,用于执行加法、减法、与操作等指令。

### ALU构成

ALU由多路选择器和基本逻辑门构成。选择信号线决定执行何种操作。

### 实现加法与减法

加法和减法由同一个模块实现,选择信号决定计算方法。

### 实现与或操作

与操作由32个并联AND门实现,或操作由32个并联OR门实现。

### 选择操作

选择信号线S0决定执行加法还是减法,是否执行与或操作。S1决定是否执行减法。

### 简单ALU设计

仅支持加法、减法和与或操作。由多路选择器和基本逻辑模块构成。

### 优化设计

考虑存储位宽不同,以及有无进位与进位情况。后续可以扩展更多指令支持。

理解ALU工作原理,对计算机组成原理和数字电路设计有重要意义。ALU是CPU执行算数运算的核心部件。

## 75. [CS61C FA20] Lecture 17.3 - Combinational Logic Blocks: Adder/Subtractor

### 加减器结构

加减器由全加器或半加器组合而成,执行加法和减法运算。

### 单比特全加器

实现两个位a,b与进位cin的加法,得到和sum与新的进位cout。

### 多比特加法器

通过级联多个全加器,可以实现多比特数据的加法运算。

### 单比特减法器

通过两个操作数取反得补码后加1,实现a-b的减法。

### 补码

有符号整数的表示方法。用原码取反得到符号位补码,再加1得到界补码。

### 有符号减法转换

利用a的补码加b与界补码的关系,将减法转换为加法进行。

### 进位借位

减法在最后可能需要进位借位,此时生成的进位cin为1。

### 加减器模块化

通过多路选择器控制补码借位和计算结果,实现同一个逻辑单元的加减功能。

理解加减器工作原理,对数字系统设计和计算机体系结构都很重要。它是ALU的关键组件之一。

## 76. [CS61C FA20] Lecture 17.4 - Combinational Logic Blocks: Subtractor Design

### 减法转换为加法

A - B可以转换为A + (-B),其中-B表示B的相反数。

### 二进制数的否定

二进制数的否定可以通过取反后加1来实现。即将每个位从0变为1,从1变为0,然后加1。

### 条件反相器

利用补码生成电路,通过按位异或实现条件取反操作。选择信号决定该位是否取反。

### 补码电路

以32位减法为例。利用条件反相器层层生成B的补码-B,同时携带进位。

### 高位借位

减法过程中产生的高位借位,直接作为最低位的加数来实现。

### 好处

利用加法电路实现减法,可以充分利用现有加法器资源,而不需要单独设计减法器。同时计算A-B等价于A+(−B),保留了减法的数学属性。

### 溢出检测

利用加法器的溢出检测信号直接作为减法的有符号和无符号溢出检测。

理解补码技术和条件反相器的工作原理,可以有效实现减法运算。这是数字电路和CPU设计中的重要内容。

## 77. [CS61C FA20] Lecture 18.1 - Single-Cycle CPU Datapath I: RISC-V Processor Design

### 本模块内容

本模块将设计一个支持RISC-V指令集的单周期处理器数据通路。

### RISC-V概述

RISC-V是开源ISA,包括多种长度和扩展集的32位和64位版本。RISC-V处理器可以执行多种编程语言二进制码。

### 数据通路和控制单元

处理器内部主要包含数据通路和控制单元两个部分。数据通路执行指令,控制单元控制数据通路设置。

### 数据通路组成

数据通路包含寄存器文件、程序计数器、算术逻辑单元等功能单元。其中ALU为最常见的功能单元。

### 指令集划分

RISC-V指令集包含整数指令集、单精度浮点指令集等。本课程设计处理器仅支持RISC-V整数指令子集RB32I。

### 数据通路设计原则

针对每个指令设计专用的数据通路效率低。同一个数据通路可配置执行多个指令,控制单元控制数据通路执行不同指令。

### 处理器设计目标

最终设计一个可以执行任何RISC-V汇编或C代码的单核RISC-V处理器。该处理器将通过数据通路和控制信号设计实现。

## 78. [CS61C FA20] Lecture 18.2 - Single-Cycle CPU Datapath I: Building a RISC-V Processor

### 指令种类

RISC-V指令包含I类指令(算术逻辑运算)、R类指令(使用寄存器)、B类指令(分支)等。

### 数据通路组成

数据通路包含32个32位寄存器、程序计数器、32位ALU和控制线。

### 指令格式

不同指令格式包含操作码和操作数寄存器号。

### I类指令

I类指令执行ALU运算,读取第一个操作数寄存器,将结果写入第二个操作数寄存器。

### R类指令

R类指令执行ALU运算,读取两个操作数寄存器,将结果写入第三个操作数寄存器。

### B类指令

B类指令根据分支条件使用ALU计算跳转地址,修改程序计数器值实现跃迁。

### 控制单元工作

根据指令格式产生控制信号,使寄存器、ALU和程序计数器按照正确顺序进行读写操作。

### 数据传输

控制单元组织数据在寄存器和ALU之间传输,实现指令功能。

### 测试设计

通过给出指令集编码,说明相应的控制信号和数据传输情况,核实设计是否正确执行指令功能。

理解RISC-V处理器的数据通路和控制机制对学习微处理器设计很重要。

## 79. [CS61C FA20] Lecture 18.3 - Single-Cycle CPU Datapath I: R-Type Add Datapath

### RISC-V指令类型

RISC-V指令包含I类、R类和B类等类型。本模块设计单周期CPU的数据通路,仅支持R类指令。

### R类指令格式

R类指令采用寄存器到寄存器算数运算格式。它读取两个操作数寄存器rs1和rs2,将结果写入目标寄存器rd。

### 数据通路组成

数据通路包含程序计数器、指令存储器、寄存器文件、算数逻辑单元(ALU)等模块。

### 指令解码

通过取不同字段的指令码,直接访问寄存器文件获取rs1和rs2的值。

### ALU运算

ALU执行rs1和rs2的加法运算,计算出结果。

### 寄存器操作

寄存器文件同时读出rs1和rs2的值,并在下一个时钟上写入计算结果到rd寄存器。

### 时钟控制

时钟控制数据传输和状态机的工作顺序,实现指令的周期执行。主要控制程序计数器和寄存器文件。

### 测试数据通路

通过例程指令和不同时钟级别的状态机变化来验证数据通路是否正确实现指令功能。

设计单周期CPU数据通路核心是掌握寄存器访问、ALU运算和时钟控制机制。这有助于学习更复杂CPU的设计。

## 80. [CS61C FA20] Lecture 18.4 - Single-Cycle CPU Datapath I: Sub Datapath

### R类指令

R类指令包含加法和减法两种指令类型。

### 加法与减法

减法可以看作从被减数中减去减数的加法。

### 原数据通路

原数据通路支持R类加法指令,包含程序计数器、寄存器文件、ALU等模块。

### ALU改进

将单纯的加法器改为支持加减操作的ALU。ALU通过控制信号选择执行加法或减法。

### 控制信号

新增一个ALU控制信号aluop,当aluop为0时执行加法,为1时执行减法。

### 指令支持扩展

通过设置ALU的功能码,一个数据通路可支持R类指令集中的加法、减法等多种算术逻辑操作。

### 测试方法

给出测试指令,观察控制信号和数据通路操作,验证是否正确执行各种R类指令。

改进ALU支持减法,是一个扩充CPU指令集的例子。正确设计控制可以实现数据通路的灵活配置。

## 81. [CS61C FA20] Lecture 18.5 - Single-Cycle CPU Datapath I: Datapath with Immediates

### I类指令格式

I类指令使用立即数,格式与R类不同。它包含目标寄存器rd、源寄存器rs1和12位宽的立即数imm。

### 原数据通路

原数据通路支持R类指令,包含程序计数器、寄存器文件和ALU。

### 修改ALU输入

将ALU第二输入从源寄存器rs2改为立即数imm,ALU执行rs1加imm操作。

### 多路选择器

使用多路选择器选择ALU第二输入,当b_sel为0选择rs2,为1选择imm。

### 生成立即数

从指令字段提取12位立即数填充低12位,高20位填充源寄存器最高有效位实现补码扩展。

### 数据传输

同时从寄存器文件读取rs1和rs2,ALU运算结果写入目标寄存器,更新程序计数器。

### 测试方法

给出I类测试指令,观察控制信号和数据传输过程,验证是否正确执行指令功能。

采用多路选择器和立即数生成方法,一个数据通路实现R类和I类指令支持。

## 82. [CS61C FA20] Lecture 19.1 - Single-Cycle CPU Datapath II: Supporting Loads

### 原有数据通路

原有数据通路支持R类和I类指令,设计为四个阶段执行,不涉及存储器访问。

### 加载指令格式

加载指令为I类格式,使用寄存器rs1和12位有符号扩展的立即数作为存储器地址。

### 数据通路改进

增加数据存储器模块,使用复用器选择ALU输出或存储器读数据作为写回源。

### 控制信号

设置内存读写为读、选择写回来源为存储器输出。ALU执行rs1加立即数运算产生存储器地址。

### 执行过程

依次完成指令decode、操作数预读、ALU运算、存储器访问、写回五个阶段,支持加载指令执行。

### 不同加载类型

支持8位或16位加载以及有符号/无符号类型,需要增加逻辑门和复用器支持不同位宽访问。

数据通路设计中增加存储器和选择写回来源,实现支持加载指令的通用处理器设计。

## 83. [CS61C FA20] Lecture 19.2 - Single-Cycle CPU Datapath II: Datapath for Stores

## 存储指令格式

存储指令与加载指令一样采用I格式,读取两个寄存器rs1和rs2及12位有符号扩展的立即数。

## 原数据通路

原数据通路支持加载指令,包含程序计数器、寄存器文件、ALU和数据存储器等模块。

## 修改存储器

为存储器增加写入端口data_w,支持写入操作;设置存储器读写控制信号mem_rw为写。

## 新增数据路径

从寄存器文件读取rs2内容,直接送入存储器data_w端口实现写入;设置读回数据选择信号为不使能。

## 计算访问地址

ALU使用rs1和扩展后的立即数计算存储单元地址,指向需要写入数据的位置。

## 调整立即数格式

存储指令立即数格式不同,需要更新立即数产生单元支持两种I格式立即数。

## 支持字/半字存储

通过几个逻辑门保证不会误写存储单元,实现字节和半字存储指令。

## 数据传输时序

指令译码、操作数访问、ALU计算、地址驱动存储器写入数据,在各时钟级别完成存储操作。

数据通路设计充分利用共享单元,在保证功能正确性前提下实现对不同指令类型的支持。

## 84. [CS61C FA20] Lecture 19.3 - 单周期CPU数据通路II:实现分支

在之前视频中,我们设计了类型I、S型指令的数据通路。在本次视频中,我们将学习如何将分支指令添加到数据通路中。

分支指令的功能是根据寄存器RS1和RS2中的内容进行比较,然后根据条件更新程序计数器PC的值,从而改变程序的执行流程。添加分支指承需要在数据通路中实现以下功能:

1. 比较RS1和RS2中的值,判断是否满足条件。此功能由新增的分支比较器实现。它接收一个输入控制是否为有符号比较,输出两个状态位表示是否相等或小于。

2. 计算新的PC地址值。ALU被配置为将PC与分支差值相加,得到新PC地址。

3. 是否更新PC。在PC前新增一个多路选择器,能选择是否将新PC地址写入PC寄存器。

4. 生成分支差值。与I、S型指令不同,B型指令中的差值以特定格式编码。需要进行有符号扩展。

5. 控制数据通路。需要控制分支比较器、ALU输入和PC选择器的多个路由以支持不同的分支类型。

这些建设主要修改在:

- 加入分支比较器进行RS1-RS2比较
- 在ALU输入加入PC多路选择器
- 在PC寄存器前加入多路选择器选择是否更新PC
- 控制单元需要额外控制新加路由

如此一来,数据通路实现了分支指令的核心功能:根据条件更新PC的值,从而改变执行流程。这为CPU设计奠定了基础,可以支持更多复杂指令。

## 85. [CS61C FA20] Lecture 19.4 - 单周期CPU数据通路II:加入JALR指令至数据通路

### JALR指令格式

JALR指令为I格式指令,包含目标寄存器rd、源寄存器rs1和12位立即数imm。

### 功能

JALR指令将PC+4写入目标寄存器rd,作为返回地址,并将源寄存器rs1内容加立即数imm写入PC,实现函数调用。

### 原有数据通路

数据通路包含程序计数器、寄存器文件、ALU等模块,支持I类和R类指令。

### 修改

1. 将写回器选择器增加一输入端口,选择PC+4写入目标寄存器。

2. 控制单元设置为采用I类立即数格式、ALU执行加法。

### 流程

解码-立即数生成-寄存器访问-ALU运算-PC写入-写回,完成JALR指令功能。

### 注意事项

1. PC控制总为跳转。

2. 选择器新增输入端口简化设计。

3. 控制单元设置保证指令正确执行。

通过简单修改,同一数据通路支持更多RISC-V指令,为CPU指令集设计 laid solid foundation。

## 86. [CS61C FA20] Lecture 19.5 - 单周期CPU数据通路II:添加JAL指令

JAL指令用于进行函数调用,它将返回地址保存到寄存器,并跳转到目标位置。

JAL指令采用J格式,其格式为: opcoderd, imm[11:0], imm[19:12]。立即数寻址范围为-2048~+2047字节。

为支持JAL指令,需要做以下修改:

1. 使用已有的机制将PC+4值写入目的寄存器rd,这与JALR指令类似。

2. ALU对PC和立即数取和,结果作为新的PC值。

3. 立即数生成机制升级为J格式,支持20位立即数。

数据通路中其他部分不需要改动,主要通过控制逻辑设置正确的控制信号支持JAL指令。

操作过程为:

1. 分析指令,同时生成J格式立即数和设置控制信号。

2. PC值和立即数送入ALU相加。

3. ALU输出作为新PC值。

4. PC+4值写入目的寄存器rd。

5. 更新PC和目的寄存器,完成函数调用跳转。

采用模块化设计,充分利用已有机制,以少量修改实现JAL指令支持,满足RISC-V指令集规范要求。

## 87. [CS61C FA20] Lecture 19.6 - 单周期CPU数据通路II:添加U型指令

U型指令用于支持长立即数,立即数范围为20位。

U型指令包括两条指令:

1. lui指令:将20位上立即数加载到目的寄存器。

2. auipc指令:将程序计数器与20位上立即数相加,结果写入目的寄存器。

添加U型指令仅需增加以下模块:

1. 立即数生成增加20位立即数输入通道。

2. 控制单元设置为U型立即数格式。

操作过程:

1. lui指令:生成U型立即数,ALU传输至目的寄存器。

2. auipc指令:生成U型立即数,与PC相加,结果写入目的寄存器。

测试代码路径,验证U型指令可正常执行。

数据通路设计充分利用现有资源,通过简单扩展支持全部RISC-V指令格式,满足RISC-V指令集规范要求。本设计完整实现了单周期CPU的指令执行功能。

## 88. [CS61C FA20] Lecture 19.7 - 单周期CPU数据通路II:总结

本设计完成了单周期CPU的数据通路,满足如下特点:

1. 可以执行RISC-V整个RV32I指令集指定的所有通用寄存器指令。

2. 数据通路通过模块化设计,每个模块完成明确功能。

3. 指令执行流程分为五个阶段:取指令、解码、注册读取、执行、写回。

4. 每条指令不一定参与每个阶段,不同指令在不同阶段活跃。

5. 数据通路通过控制单元配置,实现不同指令的执行。

6. 控制单元未详细设计,主要配置数据通路以支持正确指令执行。

7. 该数据通路实现仅为一种可能的设计,RISC-V具有多种实现方案。

8. 每个功能单元在某一指令下都起到了作用,整体数据通路被完全利用。

完成单周期CPU的数据通路设计,能够执行编译后的C程序。下一步将着手控制单元的具体设计,以自动配置数据通路执行各条指令。

## 89. [CS61C FA20] Weekly Lecture 08.LIVE - RISC-V Datapath

### 本次直播回顾

回顾了RISC-V单周期CPU的数据通路设计,实现了RISC-V标准指令集的执行。

### 数据通路设计

采用模块化设计方法,将数据通路分成多个独立功能单元模块,包括程序计数器、寄存器文件、ALU等。

### 指令执行流程

指令执行分为5个阶段完成:取指令、解码、寄存器读取、执行、写回。每个指令不一定参与所有的阶段。

### 各类指令支持

实现了I型、R型、S型、B型、J型和U型6种RISC-V指令格式的支持,每个指令通过控制信号配置数据通路实现执行。

### 控制单元

控制单元目前没有详细设计,通过输出控制信号来配置数据通路,支持各类指令的正确执行。

### 后续工作

下一步需要设计控制单元模块,根据指令编码自动产生正确的控制信号,从而完成对数据通路的配置,实现指令的自动执行。

### 问题答疑

解答了学生在RISC-V数据通路设计、寄存器文件实现及控制单元设计等方面的问题。

完成了单周期RISC-V CPU的数据通路设计,为后续控制单元设计打下了基础。

## 90. [CS61C FA20] Lecture 20.1 - 单周期CPU控制:控制与状态寄存器

控制与状态寄存器(CSRs)是计算机系统中重要组成部分。

CSRs用于监控处理器状态和性能,与外设设备通信。RISC-V ISA支持最大4096个CSR。

CSRs常用来计数器时钟周期数或已退休指令数,与协处理器或外设通信。通信方式为将控制字写入CSR,外设读取后写入状态。

例如设置/清除标志位实现与邮局信箱类似的升降旗机制。这就是CPU状态标志的来源。

RISC-V将CSRs设计在ISA扩展标准外,但保留访问它们的指令格式。CSR指令采用I格式,上12位用于CSR地址。

主要有两类CSR指令:一类使用源寄存器操作CSR,一类使用立即数。

常见指令有:csrrw(原子读写CSR)、csrrs/csrrc(设置/清除标志)。

本课介绍了CSRs在单周期CPU中的应用与访问方式,为后续设计CPU控制逻辑奠定基础。

## 91. [CS61C FA20] Lecture 20.2 - 单周期CPU控制:数据通道控制

本节将通过控制几个典型指令来理解单周期CPU如何工作。

每个指令的执行都在钟跳沿开始。程序计数器同时增加4来获取下个指令地址,但此值不会马上写入程序计数器,需要等到控制信号允许。与此同时,从指令存储器读取指令。读取指令和增加程序计数器的时间相当。

获取指令后,可以并行访问寄存器文件获取注册值,生成立即数等。控制单元将解析指令,同时设置控制信号。

存储字指令设置PC加4,同时设置各控制信号值以配置数据通道执行指令。在下个钟沿更新程序计数器和数据存储器完成指令执行。

分支指令与存储字类似,同时增加PC加4保存下指令地址。但分支指令需要等待比较结果来决定是否需要改变PC值。各控制信号同样在解码阶段设置。比较操作完成后,选择新PC值完成指令。

此外还探讨了数据通道内并行操作以及各块间的传输延迟相近,这使指令能够在一个钟周期内完成。总之,通过设置控制信号配置数据通道,单周期CPU能够在一个钟周期内顺序执行各类型指令。

## 92. [CS61C FA20] Lecture 20.3 - 单周期CPU控制:指令时钟

### 指令执行时间

所有指令在单周期CPU中都在一个时钟周期内完成执行。

### 指令执行阶段

指令执行分为5个阶段:

1. 指令提取阶段:获得新的指令地址并提取指令。  

2. 解码阶段:解析指令并设置控制信号。

3. 寄存器读取阶段:从寄存器文件读取操作数。

4. 执行阶段:执行ALU/运算等操作。

5. 写回阶段:将结果写回寄存器文件或数据存储器。

### 并行化

不同阶段的操作可以部分重叠执行,例如:

- 提取新指令地址的同时读取上一指令的寄存器操作数。

- 解码阶段的同时从寄存器文件读取操作数。

- 执行阶段可以与写回阶段重叠。

这通过内部并行化,在一个时钟周期内完成所有运算。

### 寄存器访问延迟

寄存器文件读写的时间约为时钟周期的一半,可以容纳在一个周期内。实现多路读写寄存器。

通过并行化和控制信号调度,单周期CPU能按时钟进行指令流水线执行。

## 93. [CS61C FA20] Lecture 20.4 - 单周期CPU控制:控制逻辑设计

### 控制逻辑构成

单周期CPU控制逻辑主要由指令ROM和组合逻辑电路组成。

### 指令ROM

根据指令编码存储每个指令对应的控制信号信息。

### 组合逻辑

根据时钟和指令信息产生管脚控制信号配置数据通路。

### 控制信号

包括时钟信号、寄存器读写使能等单个组件的控制信号。

### 控制信号时序

each pipeline stage工作在不同时钟边沿,以满足数据传输需要。

### 设计步骤

1. 指定所有模块接口。

2. 生成指令表格,记录每个指令的执行控制信号。

3. 用逻辑门描述组合逻辑电路。

4. 验证电路功能性能。

5. 实现电路门级描述。

### 关键技术

- 并行工作减小时钟周期。

- 同步元素存储中间结果。

- 控制电路保证各模块按时序操作。

本节介绍了单周期CPU控制逻辑整体设计思路,为后续实际设计奠定基础。

## 94. [CS61C FA20] Lecture 20.5 - 单周期CPU控制:总结

本课程完成了单周期CPU的编译和设计过程:

1. 从高级语言编译到汇编指令,实现软件与硬件的接口。

2. 通过逻辑门层层构建,从基础电路设计出完整CPU。

3. 设计RISC-V指令集的单周期数据通路,支持所有常用指令执行。

4. 深入解析每个指令的执行流程和时序要求。

5. 设计控制单元,通过产生控制信号配置数据通路执行指令。

6. 验证CPU能够顺序执行任意C程序编译后的RISC-V指令。

完成CPU的“软-硬”整合,实现高级语言程序自动在物理CPU上运行。

此设计 processor 的性能还有优化空间。后续工作将继续改进设计:

1. 加入流水线提高吞吐量。

2. 优化关键路径减少时候周期。

3. 添加外设支持多任务运行。

4. 实现中断和异常处理。

全面提升单片机的性能与功能实现。

## 95. [CS61C FA20] Lecture 21.1 - 流水线I:流水线

### 单周期CPU的性能问题

单周期CPU每个指令只能按顺序完成各阶段,性能受到最长指令时间限制。

### 流水线技术

同时执行多个不同指令的不同阶段,重叠执行提高吞吐量。

### 流水线作业

每个时钟各个阶段都有一个不同指令在执行。例如指令1进行取指,指令2进行译码等。

### 流水线阶段

RISC-V指令流水线主要阶段为:取指、译码、执行、访存、写回。

### 流水线潜伏周期问题

部分指令依赖于前一指令,需要额外的周期等待。

### 流水线结构

每个阶段使用独立的寄存器存储中间结果,每个时钟传递至下一个阶段执行。

### 流水线频率

不再受最长指令限制,可以达到理论最大频率。但通过量受流水线级数限制。

### 流水线提高单指令吞吐量

通过重叠执行,单个CPU同一时间可处理多个不同指令。

## 96. [CS61C FA20] Lecture 21.2 - 流水线I:处理器性能铁律

### 处理器性能评估标准

处理器性能主要取决于执行一个程序的时间。

### 处理器性能铁律

程序执行时间=指令数×每指令周期数×每周期时间

### 影响指令数的因素

- 算法复杂度
- 编程语言
- 编译器
- 指令集结构

### 影响每指令周期数的因素

- 指令集结构
- 处理器微架构实现
- 指令复杂程度

### 影响每周期时间的因素

- 微架构组成
- 工艺技术
- 电源电压
- 功率预算

### 一个例子

虽然B型处理器在某些指标上不如A型,但因CPI低,最终执行时间更短。

总之,处理器性能由上述各个方面综合影响,不能单独判断。

## 97. [CS61C FA20] Lecture 21.3 - 流水线I:能效

### 能效对性能的影响

低功耗设计可以降低频率,但影响性能。

### 功耗来源

- 功耗主要来源于静态功耗和动态功耗。

- 静态功耗主要来自漏电流。

- 动态功耗主要来自指令执行的每个翻转。

### 减少动态功耗的方法

- 降低供电电压,可以显著降低每个翻转的能量。

- 但降低电压也会降低频率,影响性能。

- 需进行速度-功耗权衡设计。

### 手机处理器设计

- 采用更低电压(2.5GHz vs 4GHz)实现平衡。

- 高端桌面CPU以性能为先,消费100W以上。

- 手机CPU重视低功耗,频率质量较低但功耗约1-5W。

### 总结

能效设计需要考虑性能与功耗的平衡,是 processor 设计的一个重要課題。

## 98. [CS61C FA20] Lecture 21.4 - 流水线I:流水线简介

本节通过洗衣房的例子,介绍了流水线概念。

例子中有4个人需要完成洗衣任务,每个任务包含4个阶段:洗衣、烘干、折叠和晾晒。

1. 串行执行需要8小时完成所有任务。

2. 流水线执行可以重叠多个任务的不同阶段,有效利用资源。

3. 每个人的单个任务时间不变,但通过并行可以提高整体吞吐量。

4. 流水线需要3个周期填充和排空,但数量越多,速度提升越明显。

5. 单个阶段的时间缩短,不改变整体流水线时间,因为依然受限于最慢环节。

6. 流水线提高CPU吞吐量的原理,与洗衣房例子类似。

本节通过日常例子很好地解释了流水线的工作原理,为后面硬件设计奠定基础。

## 99. [CS61C FA20] Lecture 22.1 - 流水线II:实现RISC-V流水线

### RISC-V指令流水线阶段

RISC-V指令流水线主要包含5个阶段:

1. 获取(IF) - 获取指令

2. 译码(ID) - 译码指令

3. 执行(EX) - 执行算术或逻辑操作

4. 访存(MEM) - 进行内存访存

5. 写回(WB) - 将执行结果写入 registers 或内存

### 流水线实现

- 每个阶段使用独立的控制线和寄存器交换数据

- 每个时钟信号间隔,指令流通过管道流动到下个阶段

- 同一时刻,不同指令分别处于流水线不同阶段进行执行

### 潜伏周期问题

某些指令依赖前一指令结果,需要额外周期存放结果,影响流水线效率。

### 流水线控制器设计

控制各个阶段时序,确保指令有效顺序流通过流水线执行。

本节以RISC-V指令集为例,说明如何在硬件上实现流水线,为后续设计奠定基础。

## 100. [CS61C FA20] Lecture 22.2 - 流水线II:流水线障碍

### 流水线障碍概述

流水线处理器执行多个指令同时,不同指令可能因资源竞争或依赖关系产生障碍。

### 三种流水线障碍

1. 结构性障碍:指令因共享资源竞争而产生冲突。

2. 数据 hazards:后继指令依赖前驱指令的输出值。  

3. 控制障碍:后继指令可能因分支指令而被无效化。

### 结构性障碍细节

1. 寄存器表必须支持多端口读写。

2. 指令和数据 caches解决主存访问竞争。

### 处理障碍方案

1. 暂停后继指令执行以等待资源。

2. 加装额外硬件资源满足并行执行。

3. 匹配流水线深度与指令集结构设计硬件。

总之,流水线障碍识别与解决是设计流水线处理器的重要一环。
