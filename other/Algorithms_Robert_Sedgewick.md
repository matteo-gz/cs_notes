# Algorithms Robert Sedgewick

> <https://www.youtube.com/playlist?list=PLRdD1c6QbAqJn0606RlOR6T3yUqFWKwmX>

## 1. 01 课程简介

### 主讲人与课程概述

- 本课程的主讲人是Bob Sedgewick教授和Kevin Wayne,两位来自普林斯顿大学的教授。

- 这是一门中级算法课程,它将着重介绍编程与问题解决的方法,并注重应用场景。

- 该课程将重点介绍两大知识点:算法方法和数据结构。算法方法用于解决问题,数据结构用于存储与问题相关的数据。两者之间互相依赖。

### 课程内容与时间安排

#### 第一部分

- 数据类型:栈、队列、 bags、优先队列等基本数据结构。

- 排序算法:快速排序、归并排序、堆排序、基数排序等常见排序算法。

- 搜索算法:二叉搜索树、红黑树、哈希表等经典搜索算法。

#### 第二部分

- 图算法:图搜索、最小生成树、最短路径算法等图算法。

- 字符串处理算法:正则表达式、数据压缩等字符串算法。

- 高级算法:运用基础算法进行求解。

### 学习算法的意义

- 算法应用广泛,影响深远。

- 算法具有悠久历史,同时不断开创新应用。

- 算法能帮助解决原本难以实现的问题。

- 算法学习具有知识性挑战。

- 了解算法有助于成长为高效程序员。

- 算法可能揭示生命与宇宙奥秘。

- 算法学习对找工作很有帮助。

### 学习资源

- 课程对应的书籍及在线资料网站。

- 课件、代码、练习题都在线资料网站上提供。

- Java语言将作为主要编程语言,但不重点讲解语法细节。

- 假设学习者已具备基本编程知识如循环、数组、函数等。

- 如需复习关注1.1、1.2两节简介。

## 2. gfSpPbJWzVs

### 联合-查找问题

- 联合-查找问题是一类动态连通性问题。针对一组对象,可以执行联合和查找两种操作。

- 联合操作是将两个对象连接起来。查找操作是判断两个对象是否连接在一起。

- 对象可以是任何东西,如像素、计算机、人、集成电路元素等。为了程序实现,我们用0-N之间的整数代表对象。

- 连接关系应满足等价关系:自反性、对称性、传递性。连接形成多个互相连通的连通分量。

### 算法模型

- 需要数据结构维护连通分量,支持联合和查找操作。

- 联合操作需要合并包含两个对象的连通分量。

- 查找操作判断两个对象是否在同一个连通分量内。

- 设计UF类,构造函数传入对象数,包含union和connected两种方法。

### 客户端测试

- 客户端从输入读取对象数和操作序列。

- 创建UF对象,读取操作对联合进行处理,不连通则连接并打印,连通则跳过。

- 客户端可以帮助验证算法是否正确实现了接口定义的功能。

### 总结

- 分析问题、设计算法模型、定义接口、编写测试客户端,这是系统解决问题的流程。

- 联合-查找问题是计算机科学的基础问题,其算法应用广泛。

## 3. X_4Qn7MNp7A

### 快速查找算法

- 快速查找算法是解决动态连通性问题的一种“急性”算法。

- 该算法使用一维整数数组作为数据结构,数组下标代表对象,值代表对象所在连通分量的ID。

- 两个对象如果数组中值相同,则认为它们连通;如果不同,则不连通。

- 联合操作将两个对象对应的数组值设置为同一个值,实现连通。

- 查找操作仅需比较两个对象在数组中的值是否相同。

### 算法实现

- 含有构造函数初始化数组,每个下标对应的值初始化为下标值。

- 联合方法找到两个对象对应的数组值,将第一个对象对应值相同的所有值改为第二个对象的值。

- 查找方法直接比较两个对象在数组中的值是否相等。

- 算法时间复杂度分析:初始化和联合操作需要遍历整个数组,时间复杂度为O(N);查找操作时间复杂度为O(1)。

- 但若连续进行N次联合,时间复杂度将达到O(N^2),速度会随问题规模而减慢,无法处理大规模问题。

### 代码实现

- 提供代码实现上述算法,包含构造函数、联合和查找三个主要函数。

- 构造函数初始化数组,联合操作查找对象值后遍历数组修改,查找直接比较值。

- 可能的bug在于联合方法直接使用第一个对象的值而非先查找它在数组中的值。

- 算法整体思路清晰但由于联合操作时间复杂度问题,需要寻找更好的算法实现。

## 4. BcRLmCS8pfw

### 快速联合算法

- 快速查找算法速度太慢,无法解决大规模问题。

- 快速联合算法使用同样的整数数组,但每个值表示树中的父节点索引。

- 算法查找操作通过比较两个对象的根节点是否相同来判断是否连通。

- 联合操作仅需将第一个对象的根节点修改为第二个对象根节点,即合并两棵树。

### 算法实现

- 构造函数初始化数组,每个值指向自己,表示每棵树仅有一个结点。

- 寻找根节点的私有方法,沿父节点反向查找直至节点值等于索引值。

- 查找操作调用寻找根节点方法后比较两个根节点是否相同。

- 联合操作修改第一个对象的根节点为第二个对象的根节点。

### 算法问题

- 算法速度比快速查找快,但随树的高度线性增长也可能变慢。

- 如果树过高,寻找根节点的时间复杂度可能达O(N)。

- 长条形树结构会导致查找开销增大,影响算法效率。

- 快速联合算法解决不了树高度问题,同样无法应用在大规模问题上。

### 代码实现

- 代码实现了构造函数、寻找根节点的私有方法以及查找和联合两个主要操作。

- 代码结构清晰,参考图形例子省去对象初始化细节。

## 5. Wme8SDUaBx8

### 加权 quick-union算法

- 加权 quick-union算法是一种改进的并查集算法,用于解决动态连通性问题。

- 它使用整数数组表示树结构,数组下标代表对象,值指向父节点。

- 查找操作仍是比较两个对象的树根是否相同。

- 联合操作额外追踪每个树的规模,优先将较小树根链接到较大树根,保持树平衡。

### 算法实现

- 数据结构为表示树结构的id数组和统计每个树规模的size数组。

- 查找操作比较id数组中两个对象的值。

- 联合操作先比较size数组两个树的规模,将较小树根链接到较大树根,同时更新size数组。

- 时间复杂度分析:初始化为O(N),查找和联合为O(α(N)),α(N)函数增长很慢,实际处理速度很快。

### 树高限制证明

- 树高只会在合并操作时增加,此时较小树规模至少翻倍。

- 树规模最多可以翻倍logN次,即任何节点深度上限为logN。

- 这证明了查找和联合时间复杂度为O(logN)。

### 路径压缩优化

- 在查找树根过程中,将路径上各节点直接指向根节点,每次降低一层树高。

- 这只需要常数时间,极大降低树高,将算法实际性能提升至线性时间。

- 加权quick-union算法通过这些技巧,可以很好解决大规模动态连通问题。

## 6. fJe11uNfLJw

### 空间概率模型

- 空间概率模型指将几何模型中的结点映射为给定区域内的随机概率状态。

- 这类模型可用于模拟许多自然现象中的随机性,如物质扩散、能量传导等。

### 渗透模型

- 渗透模型考察模块化区域的内部结点随机打开与否形成连通路径的概率。

- 模型将区域内划分为同等单元结点,每个结点以概率P为开启状态,1-P为封闭状态。

- 当顶部与底部结点通过开启结点连通时,定义该模型处于“渗透”状态。

### 计算模拟

- 通过蒙特卡洛方法对渗透模型进行计算模拟,通过统计结论估算系统处于渗透状态的临界概率P值。

- 使用并查集算法建立结点之间的连通关系,高效 判断系统是否渗透。

- 通过大量重复实验,对足够大规模模型求取P值精确度越来越高,得出渗透阈值为0.592746。

### 应用

- 渗透模型可用于模拟多种物理系统中的随机传导或扩散过程,如电场传导、流体渗透等。

- 算法模拟实现了解决数学模型难以求解的科学问题,显示出算法在工程应用中的重要性。

## 7. qwcVeId9RqQ

### 使用科学方法分析算法性能

- 根据科学方法,我们首先需要观察算法在计算机上的运行时间等自然现象。

- 然后提出运行时间模型这一假设,试图描述观察结果。

- 假设如果能准确预测更大问题规模的运行时间,即表明该模型是合理的。

- 进一步通过实验验证模型预测的正确性,不断修正模型直到符合观察结果。

### 科学方法的要求

- 实验需要规范描述,使得其他人能重复进行实验并得到相同结果。

- 提出的假设必须能被实验证伪,否则无法通过实验检验自己。

### 分析算法性能的目的

- 预测特定计算机和算法组合的运行性能,是否能解决给定规模问题。

- 比较不同算法在同一任务上的性能,为选择提供依据。

- 理解算法在理论上可能展示的性能曲线规律。

- 避免因算法选择不当导致性能问题,满足客户端需求。

### 进行实验的对象

- 具体计算机系统中的算法运行过程,将抽象算法具体化为电子运行。

## 8. NSoSLBPfoog

### 3-sum问题

- 3-sum问题是指,给定一个整数数组,统计数组中是否存在三元组(i,j,k),使得i + j + k = 0。

- 例如数组{-2,0,1,3},存在三元组{-2,0,2}满足求和等于0。

### 朴素算法

- 采用三层循环遍历所有三元组,时间复杂度为O(n^3)。

- 算法实现包含一个static方法count,它接收整数数组,内部使用三层for循环检查每一个三元组是否满足条件,如满足则计数加1。

- 主函数读取输入,调用count方法并打印结果。

### 运行时间分析

- 通过测量不同规模输入的数据集的运行时间,找到运行时间与问题规模N的关联。

- 在对数对数坐标轴下作图,通常可以得到一条直线,其斜率B表示运行时间与N的关系为Θ(N^B)。

- 对本算法数据点作图得到斜率为3,表明时间复杂度为Θ(N^3)。

- 也可以通过比较输入规模两倍时运行时间的比值,直接估算出时间复杂度中的N次方项的指数。

### 算法性能模型

- 得出时间复杂度模型对算法进行评估非常重要。

- 获得时间复杂度后可预测更大规模问题的运行时间,无需实际运行。

- 算法时间复杂度描述其计算效率,有助于算法选择和优化。

## 9. tJYBmtjsIkA

### 算法性能模型

- 算法性能模型指通过对算法进行抽象化,建立其运行时间与问题规模之间的数学函数关系。

- 利用模型预测更大规模问题的运行时间,而无需实际运行,同时解释了算法内在运行机制。

### 性能分析步骤

1. 分析算法中各基本操作及其成本。

2. 统计每个基本操作在算法中执行次数。

3. 将成本与频率相乘得出总时间体现。

4. 通过忽略低阶项,建立概略模型来表示时间复杂度。

### 性能模型简化技巧

- 选择成本最大或执行次数最多的基本操作作为代议指标。

- 使用~符号表示忽略低阶项,精简公式。

- 通过积分等数学方法简化求和运算。

### 常见时间复杂度

- Θ(1):常数阶。

- Θ(n):线性阶,与问题规模线性成比例。

- Θ(n^2):平方阶。

- Θ(n^3):立方阶。

- Θ(lgn):对数阶。

### 性能分析例子

- 1-sum问题:Θ(n)

- 2-sum问题:Θ(n^2)

- 3-sum问题:Θ(n^3)

通过对不同问题建立运行时间函数模型,能解释并比较各算法效率。

## 10. -RsX2bARq-0

### 算法性能模型

- 算法性能模型可以用来描述算法运行时间与问题规模的数学函数关系。

- 常见的时间复杂度有Θ(1)、Θ(n)、Θ(nlogn)、Θ(n^2)、Θ(n^3)等。

- 通过建立性能模型可以预测大规模问题的运行时间,而无需实际运行,同时解释算法内在机制。

### 构建性能模型的步骤

1. 分析算法各基本操作及其成本。

2. 统计每个基本操作在算法中的执行次数。

3. 将成本和频率相乘得出总时间。

4. 通过忽略低阶项简化模型,表示时间复杂度。

### 常用算法性能模型

- 二分查找:Θ(logn)

- 排序算法:Θ(nlogn)

- 线性查找:Θ(n)

- 2-sum问题:Θ(n^2)

- 3-sum问题:Θ(n^3)

### 性能模型应用

- 预测更大规模问题运行时间。

- 比较不同算法效率,选择算法。

- 通过实验验证模型是否正确描述算法。

- 提出改进算法背后的性能优化思想。

### 总结

建立算法性能模型是分析算法的重要一步,可以帮助理解和改进算法。

## 11. _wArQr-dzoE

### 算法分析的目的

- 分析算法的运行时间,预测更大规模问题的运行效率。

- 比较不同算法,选择效率更高的算法。

- 理解算法内在运行机制,为算法优化提供依据。

### 运行时间分析方法

- 分析每个基本操作的成本,统计在算法中执行次数。

- 将成本与频率相乘得到总时间体现算法难易程度。

- 使用θ符号表示算法运行时间随问题规模N的增长规律。

- 分析最好、最坏、平均情况下的时间复杂度。

### 算法分类标准

- 常用时间复杂度:Θ(1)、Θ(lgN)、Θ(N)、Θ(NlgN)、Θ(N^2)等。

- 分析到常数倍时可以用于分类和比较算法。

- 但为了预测性能,需要给出更精细结果与输入模型。

### 证明算法优劣的方法

- 构建最坏输入情况的上界,证明存在该性能的算法。

- 构建任意输入必须花费的下界,证明不可能更优的算法。

- 上下界匹配时证明该算法为最优。

- 否则是开放问题,匹配程度反映问题难易。

### 网络研究成果

- 提出新问题和新的下界。

- 不断提高已有问题的上界。

- 解决许多问题,但仍有工作等待做。

- 提供了有效的研究方向。

## 12. whcAZ7lSTJw

### 算法运行时间和内存使用分析

- 算法运行时间和内存使用分析都是分析算法性能的重要内容。

- 运行时间分析主要通过研究每个基本操作的成本和频率来推导算法的时间复杂度。

- 内存使用分析需要考虑不同数据类型如基本类型、数组和对象占用的内存大小。

### 数据类型内存占用

- 布尔类型通常占1字节。字符类型现在占2字节。

- 整型int占4字节,长整型long和浮点型double都占8字节。

- 数组要考虑开头的额外内存开销以及每个元素的内存大小之和。

- 对象包括16字节的基本开销以及成员变量和内存对齐导致的额外开销。

### 算法内存分析示例

- 采用前几节课的WeightedQuickUnionUF示例。

- 考虑对象基础开销16字节,两个int数组(id和size)开销分别为24+4N字节。

- 总开销为8N+88字节,大N情况下使用 tilde 符号表示为8N字节。

### 分析方法总结

- 可以通过实验或数学分析获得时间和空间复杂度。

- 数学分析找到关键操作,分析其成本和频率得出总复杂度。

- 通过验证实验结果,建立的模型可以用于预测更大规模问题。

- 时间和内存分析结合,都对我们理解和优化算法很有帮助。

## 13. e2vlTqoMjhU

### 栈结构与顺序存储

- 栈是一种受限线性表,只能在同一端进行插入和删除操作。

- 我们使用顺序存储来实现栈,即用数组存储栈中的元素。

### 固定数组大小的问题

- 传统数组实现需要预先指定数组的最大容量。

- 但栈结构需动态变化,无法预测其最大大小。

### 扩容数组大小的方法

- 每次插入时检查数组是否已满,若满 then 调整数组大小为原来的2倍。

- 每次删除时检查数组是否已空1/4,若是则调整数组大小为原来的1/2。

### 扩容策略的好处

- 数组调整周期较长,不频繁生成新的数组。

- 平均每个操作的时间复杂度为O(1)。

- 用于栈的内存消耗为实际元素个数的几倍。

### 总结

使用动态调整数组大小的策略可以很好地实现栈结构的动态变化特性,效率高且内存利用率好。它通过延迟数组扩容来降低平均时间复杂度。

## 14. 9P2SmUqBgpM

### 队列的数据结构

- 队列是一种链表实现的线性表,支持FIFO原则的插入和删除操作。

- 对插入操作使用了术语“入队”(enqueue),删除操作称为“出队”(dequeue)。

### 使用链表实现队列

- 使用首节点和尾节点指针记录队列的头尾。

- 出队时删除首节点,入队时添加新的节点到尾节点后。

- 实现deque和enqueue的代码类似于链表的pop和push操作。

### 使用数组实现队列

- 使用头指针和尾指针记录队列位置。

- 出队时删除头指针位置元素,入队时添加元素到尾指针位置。

- 需要处理尾指针循环回到首位置的情况。

- 同时需要支持数组扩容的功能。

### 队列的特点

- 相比栈就是从另一端进行插入和删除操作。

- 链表实现需要维护首尾节点,数组实现需要处理循环指针。

- 队列也可以使用扩容数组实现,保证动态空间分配的好处。

- 队列是广泛使用的数据结构,在并发和网络编程中尤为重要。

## 15. usgBqR-hbdU

### 泛型的概念

- 泛型允许在定义数据结构时使用参数化类型,可以支持任意类型的数据。

- 在定义类或接口时,可以在名称前添加<T>格式的参数,T代表类型的参数,可以是任何引用类型。

### 泛型的实现

- 实现通用的栈和队列接口Stack和Queue。

- 使用类型参数<T>表示其元素数据类型不限。

- 实现类 GenericStack和GenericQueue分别使用链表和数组。

### 普通类型与包装类型

- 泛型只支持引用类型,不能直接使用基本类型int等。

- Java提供包装类Integer等与基本类型对应的包装类。

- 自动装箱和拆箱可以在基本类型与包装类之间转换。

### 数组创建问题

- Java不允许直接new GenericType[],要使用Object[]数组强转。

- 这会产生“unchecked”警告,但通常可以忽略。

### 总结

- 泛型提供了一种统一的方法支持任意数据类型,提高了代码的可重复利用性。

- 通过类型参数化接口和类,可以取代以前为每个特定类型而单独编写的相应实现。

## 16. qilUxSYox8g

### 迭代接口

- Java提供迭代接口Iterable,表示集合对象可以被迭代的能力。

- 实现Iterable接口需要提供iterator()方法,返回对应的迭代器对象Iterator。

- Iterator接口定义了hasNext()和next()两种方法。

### 实现迭代

- 为数据结构如链表或数组添加iterator内部类实现Iterator接口。

- 持有current指针遍历链表元素或索引遍历数组元素。

- hasNext()判断是否有下一个,next()获取下一个元素。

### for-each语句

- 如果数据结构实现Iterable接口,可以使用for-each语法进行简洁迭代:

  for(Type x: collection)

- 避免了使用索引或显式调用next()方法的麻烦。

###  Bag数据结构

- Bag是无序存储元素的集合,仅支持add和iterate操作。

- 可以直接使用队列或栈实现,但移除出队入队操作。

- Bag接口实现更轻量,适用于仅存取但顺序无关的场景。

## 17. 0sixdU-cehs

### 基本数据结构

视频介绍了一些基本的数据结构,如数组、链表等。这些数据结构看起来很简单,但实际上可以有很多高级应用。

### 库中的数据结构

Java和其他语言中都有标准库提供数据结构如栈和队列。这些库标准化定义了接口,但性能无法保证,难以分析。

### 自己实现数据结构

相比标准库,自己实现数据结构可以了解数据结构内部工作原理和性能特征。视频给出一个学生学习经历,解释使用标准库反而容易导致低效代码。所以课程强调先自己实现,才能充分理解。

### 栈应用示例

视频给出了栈在计算机编程语言中的两个应用实例:

1. 函数调用:调用函数时会把环境压入栈中,函数返回时弹出栈顶环境。这样就实现了递归。

2. 表达式计算:使用Dijkstra两栈算法,通过值栈和操作符栈顺序计算表达式,实现递归地求值。

### Dijkstra两栈算法

算法步骤:

1. 从左到右读取表达式元素
2. 数字入值栈
3. 操作符入操作符栈
4. 遇右括号时,弹出操作符和两个值,计算然后入值栈
5. 结束时值栈栈顶是结果

视频给出了实现的Java代码,并解释了该算法的工作原理。

### 总结

基础数据结构如栈在许多编程场景都有重要应用。自己动手实现可以帮助掌握内部工作机制和性能Characteristics,避免库过于一般化导致问题。

## 18. GENxxQx9Erg

### 排序问题

排序问题是将n个项按照键的排序规则重新排列。常见的键有学生记录中的学号、字符串中的字母顺序等。

### 客户端程序

视频给出了三个客户端程序示例:

1. 对随机实数进行升序排序。

2. 对字符串进行升序排序,从文件中读取字符串并排序。

3. 对给定目录下的文件进行按文件名排序。

### 回调机制

要实现一个通用排序算法,需要考虑不同类型数据的比较规则。回调机制允许客户端通过传入比较函数,告诉排序算法如何比较特定类型的数据。

### Java中的比较接口Comparable

Java提供了Comparable接口定义了compareTo()方法。如果一个类实现了Comparable接口,就能与同类型对象进行比较。

内置类型如Integer等均实现了Comparable接口。如果定义了新的类型,也需要实现Comparable接口。

### 实现排序算法

排序算法使用less()和exchange()两个静态方法来进行数据比较和交换,而不是直接操作对象,这样就跨语言通用了。

less()方法比较两个对象,exchange()方法交换数组两个位置的元素。这样可以确保排序不会改变原始数据。

### 总结


回调机制和Comparable接口解决了通用排序如何处理不同数据类型的问题。利用less()和exchange()方法可以使排序算法在不同语言中都能正常工作。

## 19. 0nNqHW1eFUQ

### 选择排序算法

选择排序的思想是每次从未排序区选择最小(或最大)的元素,将其放入已排序区的末尾。

### 算法实现

1. 设置指针I,初始时指向数组第一个元素。

2. 遍历I后面的未排序元素,找出最小的一个。

3. 将这个最小元素与I位置元素交换。

4. 将I后移一个位置,重复2 3步,直到I扫描完整个数组。

### 时间复杂度

内层循环需要O(n)时间找出最小元素,外层循环执行n次,所以时间复杂度是O(n^2)。

### 空间复杂度

在原地排序,不需要额外空间,空间复杂度是O(1)。

### 算法特点

1. 每次找到最小元素后直接交换到最前面,采用就地交换方式。

2. 无论初始顺序如何,时间复杂度均为O(n^2)。

3. 每个数都只需要一次交换即可放到最终位置,交换次数线性 complex

### 稳定性

选择排序不稳定,相同元素在排序后的位置可能发生变化。

## 20. ou6MimDWZ7w

### 插入排序算法

插入排序的工作原理是通过构建有序序列,对于未排序数据,在已排序序列中从后向前扫描,找到相应位置并插入。

### 算法实现

1. 从第一个元素开始,该元素作为初始的有序序列。

2. 取出下一个元素,在已排序序列中从后向前扫描。

3. 如果当前元素(已排序)大于新元素,将当前移到下一个位置。

4. 重复步骤3直到找到已排序的元素小于或者等于新元素的位置。

5. 将新元素插入到该位置后。

6. 重复步骤2-5直到所有元素均排序完毕。

### 时间复杂度

平均时间复杂度为O(n2),最优情况下(数组本身已经排好序)的时间复杂度为O(n)。

### 稳定性

插入排序是一种稳定的排序算法。

### 算法特点

1. 排序过程在原地进行,不需要额外的内存。

2. 对于部分排序好的数组,效率比选择排序高很多。

3. 最差情况下的时间复杂度与选择排序相同,为O(n2)。

4. 对完全逆序的数组效率最低,每个元素都要经过全排。

## 21. NNiqkVgxaXs

### Shell排序

Shell排序是插入排序的一种改进,主要思想是通过预先对数组进行分组,然后对每组使用插入排序。

### 实现方法

1. 使用增量序列h对数组进行h排序,h排序实质是插入排序,但插入位置增量为h而非1。

2. 选择不同的增量序列重复执行上述过程,每次增量减小,例如7、3、1等。

3. 最终增量变为1时就是普通插入排序,实现完全排序。

### 时间复杂度

对3x+1增量序列,最坏情况时间复杂度为O(n^1.5)。但对部分有序数组,效率会很高。

### 增量序列问题

目前没有找到最优增量序列,常用序列包括2的幂减1、3x+1等。但未能给出平均时间复杂度准确模型。

### 优点

实现简单且对中间数据大小数组效率高。广泛用于嵌入式系统和硬件排序因代码少而高效。

### 问题与研究方向

1. 寻找最优增量序列

2. 分析平均时间复杂度

3. 与其他排序算法的对比

Shell排序利用预排序提高插入排序效率,给出了许多研究问题,是一种值得深入研究的排序算法。

## 22. fglX4Cf-sFg

### 洗牌算法

洗牌是随机重新排列一副已排好顺序的卡牌顺序的过程。

### 使用排序实现洗牌

1. 为每张卡牌生成一个随机数

2. 根据随机数进行排序

3. 由于随机数均匀分布,排序后的结果即为均匀随机排列,达到洗牌效果。

### 直接交换实现洗牌

1. 从首到尾遍历卡牌数组

2. 当前位置i,选择0到i-1范围内的随机Index j  

3. 将位置i和j的卡牌交换

4. 重复前三步,即可实现线性时间内均匀随机洗牌

### 算法特点

1. 每次交换实现局部洗牌,最后得到全局洗牌结果

2. 随机选择范围为当前范围内,保证次数随机性

3. 时间复杂度O(n),只需线性时间即可完成洗牌

4. 易实现但随机数生成需具备难度安全性

### 实际应用注意事项

1. 随机数源质量 directly affects 算法性能

2. 不能将整副牌乱序重置,而只能局部交换

3. 应用安全测试,排除数字 vulnerabiliy

选择合格的随机数源对算法效果和信息安全都有重要影响。

## 23. Ctsbm6an1CU

### 凸包问题

给出平面上的一些点集,找到将这些点全包围的最小凸多边形,这个多边形就称为这些点的凸包。

### 格拉罕扫描算法

该算法通过以下3步计算凸包:

1. 将点集根据极坐标进行排序。选取极坐标最小的点P为起点,按逆时针方向给其他点排序。

2. 使用单调栈维护凸包边界。将P入栈,然后顺序考察其他点是否与栈顶两点和自己构成逆时针角。

3. 如果是逆时针角则入栈,否则出栈。最后剩余点集即为凸包点集。

### 算法实现问题

1. 如何进行极坐标排序?需要定义点的顺序比较方式。

2. 如何判断三点是否构成逆时针角?可以利用斜率计算。

3. 如何进行高效排序?可以使用优秀的排序算法如归并排序、快速排序。

4. 如何处理特殊情况如点重合、非简单多边形导致的问题?

5. 设计一个支持这些运算的点对象类型会更高效。

总体来说,凸包算法利用了排序结果,以线性时间求解问题,给出了使用已有算法解决新问题的思路。

## 24. 1a-chpO4bgQ

### 排序算法中重要的概念

排序是计算机科学中最基础且重要的问题之一。在设计排序算法时有些重要概念需要了解。

#### 比较操作

排序依赖于关键字的比较,以决定元素的相对顺序。排序算法的效率很大程度取决于比较操作的复杂度。

#### 稳定性

如果相等元素的相对顺序在排序前后保持不变,则这个排序算法称为稳定排序。

#### 内部排序与外部排序

内部排序指排序所有数据能完全装入内存中的情形。外部排序的数据因超出内存容量,需要在内存和外存间进行数据交换。

#### 最好、最坏、平均时间复杂度

分析算法效率时考虑输入的数据 diferentes 情形,给出最好、最坏和平均时间复杂度。这有助于评估算法的性能下限和一般情况。

#### 空间复杂度

分析算法实现过程中额外使用的内存空间大小,与时间复杂度同等重要。

#### 不稳定排序算法

如冒泡排序、选择排序、插入排序等,可能改变相等元素的相对顺序。

#### 稳定排序算法

如冒泡排序、插入排序、归并排序等,保持相等元素的原有顺序。

理解这些基本概念对设计和选择排序算法至关重要。它们决定算法在不同条件下的优劣势。

## 25. dNuPJQPt0Ps

### 选择问题

给定一个有序数组,选择问题是找到第k大元素。

### 选择算法的时间复杂度

1. 使用排序后查找需要O(NlogN)时间

2. 显然算法时间复杂度的下界是O(N)

3. 理想情况下需要一个线性时间的算法

### 快速选择算法

1. 借鉴快速排序中的划分思想

2. 每次划分元素后,根据k与划分元素的位置决定在哪个子数组继续查找

3. 重复直到找到第k大元素

4. 平均时间复杂度为O(N),极端情况下为O(N^2)

### 线性时间选择算法

1973年有研究提出一种选择算法,严格线性时间选择任意第k大元素。

但实现起来比较复杂,不适用于实际应用。寻找更高效的线性时间算法仍在继续。

### 快速选择算法应用

在不需要完全排序的场景下,快速选择算法可以在线性平均时间内高效解决选择问题。

它通过划分将问题分解成子问题的思想,体现了算法设计使用正确理论指导的重要性。

## 26. w-pHijluxMM

### 等值键问题

排序时常见的情况是数据中存在大量的等值键,这给排序算法带来一定挑战。

### 标准快速排序问题

标准快速排序如果不对等值键做特殊处理,在数据存在大量等值键时时间复杂度会退化到O(N^2)。

### 三路快速排序

三路快速排序通过在划分过程中将等值键放在一起,可以有效解决等值键问题。它将数组分成三个区域:小于区、等于区和大于区。

### 算法实现

使用三个指针LT、I和GT分别标记三个区域的边界。在扫描过程中根据键值大小分别移动三个指针,保持指针之间的不变量关系。

### 特点

1. 充分利用等值键clustering的特点,在划分时就完成排序。

2. 运行时间与键值分布Entropy有关,与最优排序算法成比例关系,属于信息论优化。

3. 实现简单,在许多实际应用中的性能优异,可作为通用排序算法。

### 影响因素

三路快速排序的性能取决于数据中等值键的分布,随着等值键数量的增加,其优势将更加突出。它解决了标准快排在特定数据下的瓶颈问题。

三路快速排序利用等值键特点,通过一个简单的区分和移动指针的过程完成线性时间排序,这在理论和实践中都具有重要意义。

## 27. QV2zF17KgB4

### 系统排序算法

许多编程语言和操作系统中都包含了一种系统排序算法,例如Java中的Arrays.sort()方法。

### 系统排序算法的实现

1. Java使用快速排序实现对基本数据类型的排序,使用归并排序实现对对象类型的排序。

2. 它通过Comparable和Comparator接口支持不同数据类型和排序规则。

3. 快速排序使用三路划分方式来提升处理等值键数据的效率。

4. 同时也采取Tukey划分元素选择方法,避免使用随机数影响系统状态的问题。

### 系统排序算法的问题

尽管在理论和实现上投入了大量研发工作,但系统排序算法仍可能存在“杀手输入”,导致时间复杂度恶化到O(N^2)。

### 选择排序算法的考量因素

应用程序在选择排序算法时需要考虑数据属性如稳定性、并行化能力、内存占用等多种影响因素的结合,无法找到一个完全通用的系统排序方案。

### 常用排序算法概况

简要概括了冒泡排序、选择排序、插入排序、Shell排序、归并排序、快速排序等算法在时间复杂度、稳定性、原址等方面的特征。

选择排序算法需要结合具体应用负责各项属性,不能简单选择。系统排序提供了参考实现但可能仍存在问题,开发者需要验证排序算法的可靠性。

## 28. L8fNRwqR60o

### 优先级队列

优先级队列是一种数据结构,用于处理具有优先级的元素。它支持插入新元素,并能够删除具有最高优先级的元素。

### 优先级队列接口

优先级队列接口包括插入(put)、删除最大元素(removeMax)、判断是否为空(isEmpty)、获取最大元素(max)及元素个数(size)等方法。元素类型需要实现Comparable接口,支持两元素之间的自然顺序比较。

### 优先级队列两种基本实现

1. 不排序数组实现:插入元素放在数组末尾,删除最大元素需要扫描全数组。插入常量时间,删除最大元素线性时间。

2. 排序数组实现:插入需要找到正确位置插入,删除最大元素直接取最后一个元素。插入线性时间,删除最大元素常量时间。

### 二叉堆实现

使用二叉堆数据结构实现,可以支持所有操作的时间复杂度达到O(logN),优于上述两种实现。它通过利用树形结构的性质来维护元素之间的优先级关系。

### Top N问题

使用优先级队列可以很好地解决动态数据流中找出最大的N个元素的Top N问题。例如从交易数据流中实时追踪金额最大的交易。

优先级队列结合特定应用,可以设计出高效的算法来解决各种问题。它比栈和队列数据结构更通用。

## 29. 4jJpMlEtOqo

### 图的基本概念

图是计算机科学和离散数学中的一个重要的数据模型。图包含顶点(vertex)和边(edge)两种基本元素。

### 图的基本定义

- 顶点表示结点
- 边表示顶点间的关系或联系
- 路径是一系列以边连接的顶点序列
- 如果路径起点和终点相同,则为循环

### 连接问题

如果两个顶点之间存在路径连接,则称这两个顶点是连接的。若图中任意两个顶点都连接,则该图是连接图。

### 连通分量

将图分割成互不相交且顶点内部全连接的子图,每个这样的子图称为该图的一个连通分量。

### 常见图形处理问题

包括查找路径、求最短路径、检测图中是否存在环、计算连通分量、求最小 generating tree 等问题。这些问题的难易程度不尽相同。

### 图算法分类

图算法广泛应用于网络、通信、社交等诸多领域。为了解决不同问题,研发了很多复杂的图算法,是计算机科学与离散数学的重要内容。

以上概括了图数据结构的基本定义及常见问题形式,为后续讨论具体图算法打下基础。

## 30. aAWGLOrmpCM

### 图表示方法

计算机中表示图主要有三种方法:

1. 边集表示:使用数据结构(如数组或链表)存储所有边。

2. 邻接矩阵表示:使用二维数组存储所有可能的边关系,查询效率高但浪费空间。

3. 邻接表表示:使用数组存储每个顶点,并用链表或数组存储与其相关联的边。这是最常用的方法。

### 图处理API

为处理图数据,需要设计一个API封装图表示和操作方法:

1. 提供构造函数创建图对象。

2. addEdge方法添加边。

3. 访问属性如顶点数量和边数量。

4. 迭代器方法遍历给定顶点的邻居顶点。

### 图API实现

使用邻接表表示实现此API:

1. 数组存储各顶点,值为顶点编号。

2. 每个数组元素对应一个bag,存储与之相关边的顶点编号。

3. addEdge方法向两个顶点的bag添加对方编号。

4. 迭代器返回给定顶点bag,遍历其邻居顶点。

### 图算法示例

基于图API可以实现多个算法,如计算各顶点度数、最大度数、平均度数等。时间复杂度常数与边的数量相关。

邻接表表示与实际大规模图匹配得最好,同时支持常数时间内获取邻居顶点,是图处理的最佳选择。

## 31. -WWVDNMFX_c

### DFS算法步骤

深度优先搜索(DFS)用于图中节点的访问,主要步骤如下:

1. 从一个节点开始访问,将其设为当前节点。

2. 查看当前节点的第一个邻居节点,将其设为当前节点,同时将当前节点加入已访问节点列表。

3. 对当前新节点重复执行2,以此递归下去。

4. 若当前节点的所有邻居节点均已访问过,回退到前一个节点。

5. 如还存在未访问过的邻居节点,选择第1个未访问邻居节点作为当前节点,重复2-4。

6. 直到图中的所有节点都已访问完为止。

### DFS实现

使用递归或栈实现:

1. 递归实现直接调用自身处理子节点。

2. 栈实现将节点入栈,循环弹出并访问其所有邻居节点。

两种方式都需要使用标记数组记录节点是否访问过,避免重复访问同一节点。

### DFS应用

DFS广泛应用于图的许多问题,如查找是否存在从源点到汇点的路径、查找连通分量等。

由于递归调用深度受图结构影响较大,容易导致栈溢出等问题。但代码简单清晰。

## 32. lI9fgDPNcRs

### 广度优先搜索算法

广度优先搜索(BFS)是一种用于图数据结构的算法,它可以访问图中所有边连接到给定起始点的顶点。

### BFS步骤

1. 将起始顶点加入队列。

2. 从队列弹出顶点V,将V标记为已访问。

3. 查找V的所有未访问邻接顶点,将它们加入队列并标记为已访问。

4. 不断重复第2-3步,直到队列为空。

### BFS实现

使用队列存储待访问顶点,每次从队头取出顶点访问其未访问邻接顶点。此外还需要两个辅助数据结构:-

1. marked数组标记顶点是否访问过

2. edgeTo数组记录从每个节点到源点的路径

时间复杂度为O(V+E),空间复杂度为O(V)

### BFS性质

- 计算出源点到其他任意点的最短路径

- 遍历顶点顺序为按距离从源点增大的顺序

- 常用于网络编程、地图路径finding等问题

广度优先搜索具有很好的扩展性,可以很容易解决许多问题。

## 33. Q2vvXPGL-ow

### 1.图处理应用之连通成分

在本课中,老师提出了图处理中的一个重要概念-连通成分。连通成分指的是,如果图中的两个点之间存在路径相互联系,那么这两个点属于同一个连通成分。

老师介绍了如何使用深度优先搜索算法计算一个图中的所有连通成分。具体算法步骤如下:

1. 使用一个标记数组标记每个点是否已访问。

2. 使用一个ID数组记录每个点所属的连通成分编号。

3. 对图中每个未标记点进行深度优先搜索,在dfs中将当前点和其相邻未标记点同时标记且赋予同一个连通成分编号。

4. 重复第3步,直到所有点都标记完毕。此时ID数组中每个点的编号即为其所属连通成分。

5. 由ID数组可以支持constant时间判断任意两个点是否在同一个连通成分中。

算法时间复杂度为O(V+E),只需要一次图的遍历。它可以处理海量数据规模的大型图问题。

### 2.连通成分的应用示例

老师给出了连通成分在两个科学应用中的实例:

1. 在一个高中对性传染疾病传播的研究中,节点代表人,边代表个人接触。识别图中各连通成分可以研究疾病传播范围。

2. 在一个微粒运动实验中的图像处理任务中,将像素点构建成网格图,边代表相邻点积分值差异在阈值内。识别连通成分可以提取移动的微粒团块,从而追踪微粒运动情况。

这些科学问题都需要高效处理海量数据,连通成分算法给出了很好的解决方案。

## 34. K1fxIzuVedI

### BFS和DFS算法

BFS和DFS是两种常用的图遍历算法。

BFS是广度优先搜索算法。它从源点开始访问最近的节点,然后依次访问更远的节点,实现按照距离源点增加的顺序遍历图中的所有节点。

DFS是深度优先搜索算法。它从源点开始递归访问节点,会先访问最近的节点,但会深入该节点的子节点,一直遍历到无法继续为止,然后再回溯其他节点,实现访问图中的所有节点。

### 连通分量问题

连通分量指一个图中可以相互访问的节点组成的最大子图。

使用DFS可以计算一个图中的所有连通分量。具体算法是:

1. 使用标记数组记录每个节点是否访问过

2. 使用ID数组记录每个节点所属的连通分量编号

3. 对每个未访问节点进行DFS遍历,同时将当前节点和相邻未访问节点标记和赋予相同编号

4. 重复第3步直至所有节点都标记完毕

### 判断图的性质

一些常见的判断图性质的问题及复杂度:

1. 判断是否为二分图:使用DFS有解决算法

2. 判断是否有环:使用DFS也很简单有解

3. 求欧拉回路:使用DFS有线性时间算法

4. 判断图同构:目前没有知道是否存在高效算法,是个未解决问题

5. 求汉密尔顿回路:NP完全问题,高度的难解

6. 无交叉平面图绘制:利用DFS有Tarjan提出的线性时间算法

图处理中存在简单问题和极其难解的问题,是个广阔的研究领域。

## 35. 2_FiizyHq7o

### 有向图的概念

有向图(directed graph,digraph)是一种图模型。有向图中的边都有方向,以有序对的形式对顶点进行连接。

### 有向图的基本定义

- 有向图中的边均有方向,顶点之间是以(u,v)的有序对形式连接的。

- 路径中必须按边的方向进行遍历。有向周期也必须按方向依次经过各顶点。

- 顶点有向入度和出度的概念。其中,出度表示离开该顶点的边数,入度表示进入该顶点的边数。

### 有向图的常见应用

道路网络、政治博客网络、银行间贷款关系网络、Boolean逻辑图、电路图等都可以用有向图很好地进行建模。

### 有向图算法问题

典型问题包括:是否存在从源点到汇点的路径、求最短路径、拓扑排序、强连通分量、传递闭包等问题。这些问题的难易程度不同,需要专门的算法进行求解。

有向图是一类重要的图模型。它比普通图在表示和处理上都具有更强的表现能力,在很多领域有广泛的应用。

## 36. 10oIuevrYfo

### 有向图算法API设计

算法接口的设计需要与图模型相匹配。针对有向图处理,可以设计如下API:

1. Digraph类表示有向图对象,可以添加定向边edge(u,v);

2. 添加方法add_edge(u,v)添加边u到v;

3. 迭代器方法out_edges(v)返回从顶点v出发的边所指向的顶点集合;

4. 方法V()和E()返回图中的顶点数和边数;

5. 方法reverse()返回逆向图,其中所有边的方向被反转;

### 图表示

由于实际图结构非常稀疏,不适合用邻接矩阵表示。采用邻接表存储法:

1. 使用数组存储顶点集合,每个位置存储一条链表表示其对应的出边;

2. 时间复杂度为O(V+E),只遍历一次图的边。

### 算法实例

提供完整的python代码实现了有向图与API的构建:

1. 从文件读取图数据构建Digraph对象;

2. 遍历每个顶点,打印其出边;

3. 对图重复1-2操作验证算法可行性。

该API设计兼容与无向图API,隐藏了详细实现,为后续各类有向图算法提供良好接口。

## "37. PHPMvU8ko2A"

### 图检索算法

这个视频主要讨论了有向图的深度优先搜索和广度优先搜索算法。

深度优先搜索算法用于查找给定节点可以到达的所有节点。与无向图相比,有向图中的搜索算法看起来更复杂一些。算法将每个节点标记为“已访问”,然后递归访问所有未标记的可达节点,将其标记并记录其父节点。

广度优先搜索算法用于查找从给定源节点到其他每个节点的最短路径。它使用队列来按层数访问节点,先访问与源节点距离近的节点。

深度优先搜索和广度优先搜索算法的实现代码对于有向图和无向图完全相同。主要区别在于前者使用递归而后者使用队列。

这两个算法有很多应用场景,例如程序流程分析、垃圾回收以及网络爬虫。程序流程可以看作一个有向图,每个基本块为一个节点;垃圾回收使用深度优先搜索标记对象图中所有可达对象;广度优先搜索可以实现一个简单的网络爬虫,提取整个网站中的链接。

### 多个源点的最短路径问题

这个问题需要找出给定有向图中一组源节点到其他每个节点的最短路径。可以使用广度优先搜索算法来解决:

1. 将所有源节点加入队列
2. 重复以下过程直到队列为空:
   1. 从队列中取出一个节点v
   2. 遍历v的相邻节点w
   3. 如果w未标记,标记w并记录其父节点v,将w加入队列
3. 解析得到的父节点记录即可回推各源点到其他每个节点的最短路径

这样可以在线性时间内求解这个更通用的多源点问题。

## 38. B2bxS6vVgLI

### 拓扑排序

拓扑排序是一个针对有向图的处理应用,它的任务是找到一个满足前驱关系约束的任务/课程排定顺序。

### 拓扑排序的算法

拓扑排序算法适用于无向松弛图(DAG),即没有环的有向图。它使用深度优先搜索(DFS)算法,并记录 DFS 回溯顺序得到结果。

具体步骤:

1. 对图进行 DFS 遍历记录每个节点访问顺序
2. 在 DFS 回溯时,将节点加入反向后序栈中
3. 反向后序栈中存储的顺序即为拓扑排序结果

### 拓扑排序的正确性证明

考虑图中任意一条由 v 指向 w 的边:

1. 如果 w 在 v 之前被访问过,则 w 在栈中排在 v 前面
2. 如果 w 还未被访问,则 v 访问后会先访问 w
3. 不存在 w 被访问但未回溯的情况,因为图无环

因此排序结果满足所有前驱节点在后继节点之前的约束。

### 检测有向图是否存在环

如果图存在环,则无法进行拓扑排序。因此可以使用 DFS 检测有向图是否存在环。当访问一个节点时,如果发现其前驱节点已经被访问过,则表明存在环。

拓扑排序和环检测在许多领域有广泛应用,如程序流程分析、编译优化、项目计划等。

## 39. zFgkK4g65ys

### 最短路径算法概述

在有向或无向图中求最短路径是图算法中一个重要的问题。它有很多应用,如交通路线规划、数据通信网络、生物化学反应等。

### Dijkstra算法

Dijkstra算法用于无权图或非负权值图中求单源最短路径。

算法流程:

1. 将源点定义为已处理顶点集合中的元素
2. 从残余顶点集中选择距源点最近的节点,并将其加入已处理顶点集合
3. 更新相邻顶点的距离值
4. 重复2-3步骤,直到所有顶点都被处理

时间复杂度为O(V^2)。

### Bellman-Ford算法

Bellman-Ford算法用于有正有负权值的有向图中求单源最短路径。

它重复进行松弛操作,每次选一个边进行松弛,最多松弛V-1次。如果第V次还能继续松弛,则存在负权回路。

时间复杂度为O(VE)。

### Floyd算法

Floyd算法用于任意图中计算所有点对之间的最短路径。

它使用动态规划思想,计算从每个中间点到其他点的最短路径长度。时间复杂度为O(V^3)。

以上三种算法分别处理不同类型图的最短路径问题,在实际应用中选择合适的算法很重要。

## 40. LqUOoEp8JQQ

### 最小生成树(Minimum Spanning Tree, MST)

最小生成树是底在带权图上的一种概念。

它指的是一组将图中所有顶点连接起来但不包含回路的最小权值边集合。

### 最小生成树的性质

- MST是一棵树形结构,将所有顶点连通但不包含回路
- MST包含图中所有顶点,但边数恰好为V-1条  
- MST的权值和是所有可能生成树中最小的

### 最小生成树的应用

MST广泛应用于计算机科学、工程学和自然科学领域:

- 交通网路设计
- 数据通信网路
- 图像处理
- 生物学和医学研究等

### 最小生成树算法

常用算法包括:

- prim算法
- kruskal算法
- 貌似本质上都利用了贪心思想

它们都可以在稠密图和稀疏图上都以线性时间复杂度O(ElogV)解决最小生成树问题。

## 41. MST-Greedy

### 贪婪算法

贪婪算法是一种常用的算法设计思路。它通过每次做出当前看起来最优的选择,从而求解问题。

### 最小生成树的贪婪算法

最小生成树(MST)的贪婪算法如下:

1. 将所有边标记为灰色
2. 找到 cuts 没有黑色边的 cuts
3. 将 cuts 中权值最小的边标记为黑色
4. 重复步骤2-3,直到得到 V-1 条黑色边

如此便找到了MST。

### 证明贪婪算法的正确性

1. 由于总是选择 cuts 中权值最小的边,所以黑色边一定在MST中
2. 当黑色边未满 V-1条时,必定存在 cuts 没有黑色边
3. 重复1-2直到得到 V-1条黑色边,此时连接图的黑色边即为MST

### 移除简化假设

1. 边权不一定不同时,MST 可能不唯一
2. 图不一定连通时,得到森林极值生成树

但贪婪算法本身仍是正确的。

### Kruskal 和 Prim 算法

它们是MST贪婪算法的两个具体实现,主要区别在于选择cuts和求最小边时的实现方法。

## 42. noOBvumt1ac

### 边加权图的API设计

实现最小生成树算法需要为带权图设计API。

1. 定义Edge类来表示加权边,包含两个顶点和一 double权值

2. Edge实现比较接口,支持按权值大小进行比较

3. Edge提供获取顶点和权值的方法

### 图的API设计

1. EdgeWeightedGraph类表示带权图

2. 构造函数可以传入顶点数创建图

3. 提供添加边的操作addEdge()

4. 提供根据顶点获取其相邻边的操作adjacentEdges()

### 最小生成树的API设计

1. MST类表示最小生成树

2. 构造函数传入EdgeWeightedGraph计算MST

3. 提供遍历MST边的迭代器edges

4. 提供获取MST总权值的方法weight  

### 实现和测试

1. 使用边索引数组表示图

2. 测试客户端从文件流创建图,计算MST边及权值

3. 旨在为MST算法提供便利的抽象,隐藏具体实现细节

这样设计的API实现简单,并为后续算法开发laid良好基础。

## 43. 0pZ8PB-Zfe4

### Kruskal算法

Kruskal算法是一种计算MST的经典贪心算法。

#### 算法思想

1. 对图中的所有边根据权值从小到大进行排序

2. 依次考虑每条边,如果添加此边不会形成回路,则将其添加到MST中

3. 重复步骤2,直到MST中边数达到V-1为止

#### 算法流程

1. 使用优先级队列将所有边插入,按权值从小到大排列

2. 使用并查集数据结构维护每个连通分量

3. 取出第一条边e,如果e的两个端点在同一连通分量,则跳过此边

4. 否则,将两个连通分量合并,并把e加入MST中

5. 重复3-4步骤直至MST中边数为V-1

#### 时间复杂度

对于E条边和V个顶点,使用优先队列将时间复杂度限制在O(ElogV)内

并查集操作的时间复杂度很低,可忽略不计

所以Kruskal算法的总时间复杂度为O(ElogV)

它具有很好的扩展性,适用于处理大规模稠密图问题。

## 44. JbmIz2sz1IQ

### Prim算法

Prim算法是使用贪心策略计算最小生成树的另一种算法。

#### 算法思想

1. 从任意一个点开始,构建生成森林

2. 在还未加入的点之间,选择与生成森林最近的边接入生成树

3. 重复执行第二步,直到所有的点都加入生成树为止

#### 算法流程

1. 选择一个起始点,将其置于最小生成树MST和优先队列PQ中

2. 取出PQ中的最小边,将另一端点加入MST和PQ

3. 查找新加入点的邻边,更新PQ

4. 重复2-3步,直到所有点都加入MST为止

#### 时间复杂度

同Kruskal算法,使用优先队列的时间代价是O(ElogV)

访问每个边一遍,最终时间复杂度也是O(ElogV)

Prim算法避免了Kruskal算法需要排序所有边的开销

但它需要重复访问已在MST中的边,总体效率与Kruskal相当。

Prim算法思想简单,实现相对容易,适用于稠密图。

## 45. VzYLvFO12_0

### 最小生成树的理论开问题

计算机科学界长期未解的一个问题是是否存在线性时间复杂度的MST算法?

目前已有很多近似线性时间的算法,但证明线性时间下限或找到一定线性时间算法尚未成功。

### Euclidean MST问题

对平面点集求MST,该图是隐含稠密图,点对点间边数为O(n^2)。

已有算法无法在此情况下得到满意复杂度。但可以利用几何信息,在O(nlogn)时间内解决Euclidean MST问题。

### 聚类问题

给一组对象及其距离函数,将对象划分为k个群集,使不同群间对象距离最大。

常用的单链聚类算法可以利用最小生成树算法在线性时间内解决。MST算法广泛应用于科学研究中的大数据处理。

### 算法进展

许多理论计算机科学家长期研究MST问题。已得到近似线性时间算法,但是否存在一定线性时间算法仍未解决。

MST问题给出了其他图算法问题的研究方向,比如是否存在更优算法。它值得深入研究。

## 46. gcPhkSpO2mk

### 最短路径问题

在带权有向图中求某一点到另一点的最短路径,称为最短路径问题。

### 最短路径问题的变种

- 单源最短路径问题:求一点到所有点的最短路径
- 所有点对之间的最短路径问题

### 图的API

设计有向带权图和路径的API,包括:

- Edge类表示边
- EdgeWeightedDigraph类表示图
- ShortestPath类计算单源最短路径

### 测试客户端

测试客户端会打印源点到每个点的最短路径:

1. 打印点对的距离
2. 打印路径中各条边

这样可以输出sample图中的最短路径,验证算法正确性。

### 最短路径应用

最短路径算法广泛应用于:

- 导航路径规划
- 网络传输
- 图像处理
- 生物医学等

它提供了许多实际问题的解决模型,如物流调度、交通规划等。

## 47. uAb1Z5P9zfA

### 最短路径问题上下文

介绍最短路径算法背景,可以帮助我们更好理解各种算法。

### 有向带权图的基本属性

- 图表示实际问题模型
- 边权表示两点间关系代价
- 最短路径树表示一点到其他点最优解

### 数据结构设计

使用两个数组存储:

1. 每个点最短路径长度
2. 每个点上一条边,表示路径

以此获取任意两点路径。

### 边松弛操作

检测一条边是否可以提供更优解,如果可以就更新数据结构改用此边。

### 最短路径优化条件

如果满足条件,证明找到最短路径:

1. 长度为某路径长度
2. 任意边权和不小于两端点长度和

### 一般算法框架

重复边松弛直到满足优化条件,但未说明选择边顺序。

### 算法复杂度分析

若有E边V点,使用优先队列时间复杂度为O(ElogV)。

## 48. uzHJXbToiIU

### 迪杰斯特拉算法

迪杰斯特拉算法用于在带有非负边权重的图中查找源点到其他所有点的最短路径。

算法的思路是:

1. 初始化 distTo 数组,源点距离为 0,其他点距离为正无穷大

2. 将源点加入优先队列

3. 重复以下步骤,直到优先队列为空为止:

   - 从优先队列中取出距离源点最近的点 v

   - 遍历以 v 为起点的所有边

   - 如果通过该边可以得到到终点 w 更短的距离,就更新 distTo[w],并将 w 加入/移除优先队列

4. 算法结束后,distTo 数组中存有源点到其他每个点的最短距离

可以使用二叉堆实现优先队列,这样每个操作的时间复杂度可以降低到 O(logV)

这使得算法的总时间复杂度变为 O(ElogV),在现实世界中的稀疏图上是高效的。

算法是正确的,因为每条边只会被恰好放松一次,这可以保证 distTo 数组保存的一直是最优值。

### 迪杰斯特拉算法与普里姆算法的关系

迪杰斯特拉算法和普里姆算法很相似,都可以用来构建图的生成树。

不同之处在于:

- 普里姆算法选择接近已在树中的任意节点距离最近的节点
- 迪杰斯特拉算法选择通过树到达非树节点路径最短的节点

而两者的算法流程和实现代码都十分相似。

### 相关应用

- 导航软件计算目的地最短路径时使用
- 社交网络中的关系推荐
- 计算机网络中的路由选择
- 计算机游戏中的路径规划

### 优先队列实现

支持不同操作的时间复杂度:

- 无序数组:插入和删除最小元素都为O(V),总时间复杂度O(V^2)
- 二叉堆:每个操作O(logV),总时间复杂度O(ElogV)  
- 4-叉堆:删除最小元素更快,在Dense图上性能较好

理论上还有可以降低到O(E+VlogV)的优化结构,但在实际中二叉堆效率已足够。

## 49. Qp9zy9qMJzE

现在我们来看 shortest paths 在有向无环图(directed acyclic graph, dag)上的应用。

如果图中含有边权值,则称为有边权值的 dag。shortest paths 的输入是这样的图。由于 dag 中没有环,所以找到 shortest paths 的算法会更简单。

我们可以根据拓朴排序顺序考虑顶点,由于没有环,所以存在一个拓朴排序顺序使所有边都指向比它大的顶点。然后我们根据这个顺序逐个放松图中的所有边。

例如,考虑一个边权值 dag。首先我们使用拓朴排序算法排序其顶点。然后从顶点 0 开始,放松所有从它指出的边,找到到顶点 1、4 和 7 的 shortest paths。

同理,考虑顶点 1、4、7,依次放松它们指出的边。在每个阶段都可能找到新的 shortest paths。最后我们得到从源点到图中每个顶点的 shortest path 树。

这种算法之所以管用,是因为每条边只被放松一次。放松后满足 shortest paths 的有效不等式。由于排序顺序,2V 永不会改变,边权也不会改变,所以不等式持续成立,找到的就是实际 shortest paths。

此算法的时间复杂度是 O(E+V),其中 E 为边数,V 为顶点数。它可以直接解决带负边权的情况,也就是可以找到dag中的longest paths。

这提供了一种高效的解决shortest/longest paths问题的方法,并且可以应用于各种问题,例如场景剪裁和任务调度问题等。

## 50. A54rUI6CPSs

### 任务调度问题

许多实际问题可以看作是一个任务调度问题,即确定任务的执行顺序以满足某些约束条件。

### 无环任务依赖图

可以用有向无环图表示任务间的依赖关系:

- 节点表示任务
- 有向边表示任务的前后依赖顺序

### 最早开始时间(Earliest Start Time)

若考虑任务执行时间,则每个任务都应该有一个尽早开始执行的时间:

- 入度为0的任务EST为0
- 其他任务EST为其前驱任务完成时间之和

### 拓朴排序和任务调度

使用拓朴排序计算任务的执行顺序:

1. 对任务图进行拓朴排序
2. 根据排序顺序计算每个任务的EST
3. 按EST非递减顺序安排任务顺序

如此可以保证满足任务依赖关系的最早开始调度。

### 应用

- 项目计划管理
- 生产线任务安排
- 计算机程序编译依赖
- 布局和排版 задач
- 过滤与渲染pipeline

任务调度问题是常见的、实用的最短路径问题应用实例。

## 51. W8_dc-P_Zt8

### 最大流问题

最大流问题的输入是一张带权的有向图,包含源点s和汇点t,边上的边权表示边的容量。

最大流问题的要求是在满足容量限制和流量平衡条件下,从源点s向汇点t发送最大流量的流配置。

### 流的定义

流是为每条边分配流量的函数,流量必须大于等于0小于等于容量,且每个非源汇点流入流出流量相等。

### 最大流问题与最短割问题

最大流问题是找到一种流配置使源点到汇点的流量最大;最短割问题是找到图中s和t间隔开的最小切分。

这两个问题表达了同一个求解图结构划分的想法,它们是对偶问题,解决一个等价于解决另一个。

### 最大流问题的应用

1950年,最大流问题被应用来研究苏联向东欧国家供应铁路的流量配置。

今天,它普遍用于网路传输、图像分割、社交网络信息流控等领域,给出了许多实际问题的解决模型。

随着数据量的增长,我们需要高效算法来解决这类大规模图处理问题。这也是最大流和最短割算法研究的动机。

## 52. Yd1Hsw1vV2k

### Ford-Fulkerson算法

Ford-Fulkerson算法是求解最大流问题的一般方法。它从初始化没有流开始,查找源点到汇点的增广路,沿路增加流量。

### 增广路

增广路是从源点到汇点的路径,满足:1. 路径边向前边剩余容量大于0 2. 路径边向后边流量大于0。

### 总体步骤

1. 寻找一条增广路
2. 沿增广路增加流量,增加向前边,减少向后边
3. 保持每个非源汇点流入流出平衡
4. 重复1-3,直到无法找到增广路为止

### 关键点

1. 向后边减流是为了保持流量平衡
2. 每次增量路径最大可增加流量=最饱和向前边残余容量和最空向后边流量的最小值
3. 当每条从源到汇的路径都没有增广路时,算法终止

### 问题分析

1. 如何确定最大流已经求得
2. 如何在图中快速找到增广路
3. 算法是否一定能收敛

Ford-Fulkerson算法提供了一种通用框架,但其详细实现和性能还需进一步研究。

## 53. RXXE3g-l13s

### 流值定理

任何流F在任何割(S,T)上的流量总和为F的流量值。

### 弱对偶性

任何流F的流量值总是小于等于割(S,T)的割容量。

### 增广路定理

1. 如果存在增广路,流F不是最大流
2. 如果F是最大流,则不存在增广路

### 最大流最小割定理

如果下面三个条件任何两个成立,则其他一个也成立:

1. 存在一个割的割容量等于流F的流量值
2. F是最大流
3. 不存在增广路

### 求最大流算法

Ford-Fulkerson算法找到所有的增广路,沿增广路增加流量,知道没有增广路为止,即找到最大流。

### 求最小割

当流F为最大流时,根据最大流值等于该最小割的割容量,采用图搜素方式求得最小割。

最大流最小割定理统一了最大流和最小割问题,证明了Ford-Fulkerson算法能找出最大流。

## 54. uuYzik04XBY

弗拉-傅尔坎森算法用于计算网络中的最大流问题。最重要的就是找到增广路,然后增大流量。

通过广度优先搜索(BFS)可以找到增广路。如果找不到,说明已经达到最大流。但不一定每次都能找到,可能会来回摆动。

假设边上容量都是整数,那么每次增广都只能增加或减少1单位容量。这意味着增广次数不超过流量值。

如果边容量在1到某个最大值U之间,算法会保持流量整数值。找到的最大流也一定是整数值。

存在增广次数限定的积分性定理。如果存在整数最大流,那么弗拉-傅尔坎森算法计算出来的就是这个整数最大流。

应避免算法在一个网路上来回增广,这样会大幅增加计算次数。

找增广路有以下几种简单方式:

1. 最短路:增广路边数最少

2. 最宽路:增广路瓶颈容量最大  

3. 随机路径

4. 深度优先搜索

这些方法的增广次数有上限,但实际网络下可能远低于上限。

不同网络可能适合不同找路算法。实际很多大网络都能用较少增广次数快速求解最大流问题。

## 55. -7-N-TW6Mj0

### 流量网络及边

最大流问题需要将原图转化为流量网络,每个边需要保存当前流量和容量信息。

定义FlowEdge类来表示边,除原有属性外增加流量和残余容量属性。

计算残余容量的公式是:正向边为容量减流量,反向边直接为流量。

### 流量网络图表示

由于存在正反向边,需要将每个边加入两端的邻接表中。

包含流量和容量信息的边用于表示流量网络中的边。

### 系统API

FlowEdge定义基本操作接口,FlowNetwork定义图遍历接口。

### Ford-Fulkerson算法

算法主体包括:

1. 检测是否存在增广路径

2. 计算增广值和路径中瓶颈边

3. 沿路径增加流量

4. 更新总流量值

### 检测增广路径

采用广度优先搜索在残余网络中查找s到t路径,如果找到返回true。

### 最大流实现

由FlowEdge、FlowNetwork和Ford-Fulkerson算法主体实现最大流算法。

每次增广后流量增加,直到无法找到增广路径为止,返回最终流量值。

## 56. m-cJ51XptaA

### Ford-Fulkerson算法运行时间分析

1. 每次增广的复杂度为O(E)

2. 最多需要进行V+E次增广

- 因为每个顶点最多入队一次被搜索

3. 因此Ford-Fulkerson算法的运行时间为O((V+E)E)=O(V*E^2)

### 提高Ford-Fulkerson算法性能

1. 使用优先队列找最短路径,算法变成O(V*E*logV)

2. 使用多源BFS加速增广路径搜索

3. 使用更智能的增广策略,如最宽增广等

4. 使用Dinic算法的层层剥洋葱思想,设计高效层搜索算法

### Dinic算法

1. 层级图搜索分层地寻找增广路径

2. 每一层使用增广过程求出层容量

3. 复杂度为O(V^2*E)

4. 是当今求解最大流时间复杂度最优的算法

5. 但实现难度大,难以直接用于不同类型网络

### 其他优化算法

push-relabel算法是另一个时间复杂度O(V^2E)的算法,但实现难度也较大。

实际工程中,Ford-Fulkerson及其优化版本性能普遍能满足要求。

## 57. djmHnA-5TQ8

### 字符串的概述

1. 字符串是字符序列的quence,不同编程语言对字符串的实现方式不同

2.  ascii codes定义了128个字符,后来发展出unicode标准代表全球各种文字

3. 在Java中,字符串是不可变的字符序列,一个字符是16位二进制数

4. 字符串主要操作包括获取长度、获取指定索引字符、获取子字符串

5. 子字符串操作时间复杂度为常数时间O(1)

### Java字符串实现

1. Java字符串Internal采用char数组存储,带有offset和length属性

2. 长度操作获取length属性值,索引操作获取char数组对应索引字符

3. 子字符串操作通过offset和length值创建新字符串对象

4. 连接操作需要复制整个字符串,时间复杂度与字符串长度线性相关

### StringBuilder类

1. StringBuilder存储字符的内部数组是可变的,增量增加容量

2. 长度获取通过length属性,索引和连接操作时间复杂度为常数时间

3. 但子字符串提取需要创建新数组,时间复杂度线性相关

4. 用于需要频繁连接的场景,如从输入建立字符串

### 字符串排序比较函数示例

给出两个字符串,返回它们最长公共前缀长度的函数实现。时间复杂度与最长公共前缀长度线性相关。

### 结束语

强调不同编程语言和场景下字符串实现的不同,以及根据应用评估字符串算法性能。

## 58. S3HjlVv6x7Y

### 键索引计数算法原理

算法需要处理的是一个小整数数组,先统计每个小整数在数组中出现的次数,将次数信息存储在一个计数数组中。

### 统计各小整数出现次数

遍历原始数组,用小整数作为索引访问计数数组,将对应的元素值加1,这一步时间复杂度为O(N)。

### 计算累加和

再遍历计数数组,将每一个元素值与前一个元素值相加,得到的是小于当前索引小整数的元素个数,时间复杂度为O(R)。

### 根据累加和将元素移动到目标位置  

再遍历原始数组,用元素作为索引访问累加和数组取得目标位置,将元素移动到该位置,时间复杂度为O(N)。

### 整体时间和空间复杂度

由于R通常为常数,因此算法总时间复杂度为O(N),空间复杂度为O(N+R),在R为常数情况下,也为线性时间。

### 算法特点

1. 对于小整数类元素特别有效
2. 时间和空间复杂度可达到线性
3. 算法过程稳定

它提供了一种在某些特定条件下比对数级时间更高效的排序方法。

## 59. n7jfknr2Bxw

### LSD基数排序原理

LSD基数排序对固定长度字符串进行排序,以每个位置的字符从右至左顺序进行基数排序。

### 基数排序每个位置的字符

使用键索引计数算法,以当前位置字符作为键,对字符串进行稳定排序。

### 排序串行执行

从字符串最右字符开始,逐个字符位置进行基数排序,以保证排序稳定性和每个位置字符的顺序。

### 时间复杂度

若字符串长度为w,则算法需要w轮排序,每轮使用O(n)时间的键索引计数算法,整体时间复杂度为O(wn)线性时间。

### Java实现

利用char数组存储串及位置信息,改写键为字符后的键索引计数算法实现每个字符位置的基数排序。

### 历史原理

19世纪人口普查使用穿孔卡存储数据,Homeith发明机器分类统计,IBM glor化,卡片Sorter利用基数排序重新排列失序卡片。

### 程序存储

当时利用卡片一行一条记录程序,编号保持顺序。如果翻乱,可用卡片Sorter基于编号恢复顺序,影响深远。

### 总结

LSD基数排序在历史上及实践中广泛应用,时间复杂度线性且实现简单,对固定长度关键字仍被广泛使用。

## 60. 1XdrDjreqJM

### MSD字符串排序(MSD String Sort)

MSD字符串排序是一种递归的排序算法,它利用键索引计数算法对字符串数组先按第一个字符进行排序,然后对每个子数组递归使用同样的方法排序后续字符,直至所有字符串排序完毕。

### 算法流程

1. 使用键索引计数对字符串数组首字符进行排序

2. 递归对每个首字符的子数组进行同样操作排序第二个字符

3. 若两个字符串的前n个字符都相等,则需要比较剩余所有字符

4. 短字符串视为含有最小字符作为结束字符可以提前结束比较

### 时间复杂度

在最坏情况下需要比对所有字符,时间复杂度为O(N*W)极其情况;若随机分布则仅需要比对一小部分字符,为O(N*logR(W))亚线性时间。

### 优化方法

1. 小数组使用插入排序

2. 从正在比较的字符起始位置进行插入排序

3. 避免递归中产生过大的计数器数组耗费内存

### 与快速排序比较

快速排序内循环动作少且数据处于缓存中 einmal性能较好;而MSD字符串排序在计数和随机访问中性能较差。

### 其他应用场景

MSD字符串排序适用于字符串特征比较清晰的排序场景,如编码、 ID号等。当字符串前缀相似时,快速排序性能更优。

## 61. QwzPkViilYA

### 3-way基数快速排序

该算法结合了快速排序和基数排序的优点,通过采用3路划分策略对字符串进行基数排序。

### 算法流程

1. 对字符串数组首字符进行3路划分为小于、等于、大于该字符的三部分  

2. 对首字符相等的部分,递归对第二字符进行3路划分排序

3. 以此类推,逐字符递归排序,直至字符串结束字符或单个字符数组结尾

### 时间复杂度

在随机分布的情况下,平均时间复杂度达到O(NlogN)字符比较次数。

而对于具有长前缀的字符串,只需重复比较前缀字符即可,大大减少比较次数。

### 优点

1. 缓存性能好,短内循环

2. 不占用额外内存

3. 对具有非随机特征的字符串(如ID号)效率高

4. 性能更稳定,难构成最差情况

5. 实现简单

### 总结

3-way基数快速排序通过有效利用字符串特征,在保证平均时间复杂度的同时可以适应不同字符串分布,性能更稳定。适用于大量字符串排序场景。

## 62. V2yMD-vpndA

### 前言

在这次讲座中,我们将了解到后缀数组和使用字符串处理的后缀数组数据结构。

### 关键词查询

关键词查询是一个常见的操作,即给出一个文本和一个查询字符串,返回查询字符串在文本中所有上下文出现的位置。这可以通过对文本进行后缀排序实现。

具体来说,首先对文本生成所有的后缀,然后对这些后缀进行排序。这样同一个子字符串相邻的后缀会被放在一起。然后通过二分查找来快速查找查询字符串,并返回它在排序后的后缀数组中的位置。从而可以得到查询字符串在原文本中所有的匹配位置。

### 最长重复子串问题

给出一个字符串,找出其中最长的重复子串。

暴力算法是尝试所有可能的起始索引和长度,进行字符串比较,时间复杂度高达O(n^3)。

使用后缀排序可以在线性时间内解决这个问题。具体来说:

1. 对给定字符串生成所有后缀
2. 对这些后缀进行排序
3. 遍历相邻后缀,计算其最长公共前缀长度
4. 记录最大长度,即为最长重复子串

这种方法时间复杂度为O(n),可扩展到海量数据量。

### 算法问题

如果有极长的重复子串,后缀排序算法会退化到O(n^2)。因为需要对所有的后缀进行比较来计算最长公共前缀。

### Manber-Myers算法

Manber-Myers算法是一次性解决这个问题的算法,它可以在线性时间内完成后缀排序,即便存在极长的重复子串。

该算法通过反复增加比较的字符数来进行赋值,每次都可以在线性时间内完成。同时它使用索引技巧,保证比较两个后缀时的时间复杂度是常数级。

这样整个后缀排序就可以在线性时间内完成,找到最长重复子串问题也可以线性时间解决。

### 总结

后缀数组是字符串处理中的一个重要数据结构。针对海量数据,需要设计线性时间或子线性时间的字符串处理算法。Manber-Myers算法是处理极长重复子串问题的经典算法。

## 63. el9-Vb6iNPM

### 后缀数组和字符串处理

本节将介绍后缀数组和使用此数据结构进行字符串处理。

后缀数组是一种很重要的数据结构,能实现之前无法实现的字符串处理应用。

#### 关键词上下文搜索

关键词上下文搜索是一种比较旧的老思路。给予一长文本,预处理它以实现快速子字符串搜索。即客户端可以给一个查询字符串,系统返回该字符串在文本中的所有匹配位置及其上下文。

#### 后缀排序算法

一种利用后缀数组解决关键词上下文搜索问题的算法是后缀排序算法。

具体做法是:

1. 对输入字符串形成所有后缀。

2. 对后缀进行排序。这样相关子字符串就聚集在一起了。

3. 使用二分搜索找到查询字符串,然后扫描排序结果输出匹配位置。

这是一种非常优雅高效的解决方案。

#### 最长重复子字符串问题

给一个字符序列,找到其中最长的重复子字符串。

这对科学数据分析很重要,如基因组数据分析。

利用后缀数组也可以很容易解决这个问题:

1. 构建后缀数组

2. 对后缀数组排序

3. 扫描相邻后缀,找到最长公共前缀即为所求。

这种算法时间复杂度是线性的。

#### Manber-Myers算法

Manber-Myers算法可以在线性对数时间内完成后缀排序,即使字符串中含有很长的重复序列。

它的思路是:

1. 按字母作为关键字进行一次排序

2. 接着按二字作为关键字重新排序

3. 以此类推,每次排序的关键字长度加倍

4. 通过建立倒排索引实现常数时间字符串比较

从而利用排序算法完成线性时间的后缀排序。

这是一种解决后缀排序难点的非常聪明的算法设计。

## 64. CqE9My0ErRI

### 后缀数组在基因组分析中的应用

基因组数据拥有特别长和重复的字符串特征,这对寻找重要序列 motif 提出了新的挑战。后缀数组可以有效解决这类问题。

### 比对 MOTIF

找到某个MOTIF(DNA片段)在整个基因组中的所有匹配位置。

利用后缀数组的对齐特征,可以利用二分查找法快速定位MOTIF,时间复杂度为O(MlogN)。

### 找重复片段

寻找基因组中最长的重复片段,如是否包含插入重复片段。

后缀数组排序特征保证重复片段在一起,可线性时间内找到最长重复片段。

### MOTIF 频率分析

统计某个MOTIF在基因组不同区域中的数量分布,分析其演化模式。

利用后缀数组对齐MOTIF实例,再结合基因组注释,可快速得到位置和计数信息。

### 配对寻找

寻找基因组中与引物配对的区域,如PCR引物设计。

后缀数组可以实现线性时间内的全局配对寻找,避免暴力O(N^2)算法。

### 注释验证

通过比对表达序列得出基因结构以验证基因组注释质量。

后缀数组可以很快地定位和对齐所有表达序列,进行定量分析。

总之,后缀数组是一种理想的数据结构,为基因组大数据分析提供了很好的算法支持。

## 65. TdP3ty3w9_A

### 后缀树在字符串处理中的应用

后缀树是一种树形数据结构,它可以从一个字符串中构建出所有的后缀作为节点,实现高效地搜索与匹配字符串。

后缀树支持四种常见的字符串操作:

1. 前缀匹配:给定一个前缀字符串,返回字符串中所有的键值对里以该前缀开头的项。算法是首先搜索到前缀对应的节点,然后递归收集该子树下的所有键值对。

2. 通配符匹配:允许在字符串中使用通配符,如点号代表任意一个字符。搜索时将通配符视为任意字符进行匹配。

3. 最长前缀匹配:给出一个查询字符串,返回符号表中与该字符串匹配程度最高的键。算法在搜索过程中记录当前路径上匹配程度最长的键,作为结果返回。

4. 有序迭代:通过递归遍历后缀树,在路径上记录节点字符序列,在找到值时输出作为键返回,实现对所有键的有序输出。

后缀树还支持其他常用操作,如获取字符串中某个motif的所有匹配位置、找出字符串中最长的重复子串等。此外,后缀树在生物信息学数据库中的应用也很重要,比如快速定位基因及其结构等。

后缀树通过利用字符串的公共前缀,大大提高了字符串操作的效率。它对大数据量的字符串匹配和处理具有很好的可扩展性,在网络基础设施、生物信息学等领域广泛应用。

## 66. 9Dk0ljfvAiM

### 串搜索问题介绍

串搜索问题是寻找模式串pattern是否出现在主串text中。一般pattern规模小,text规模大,甚至无限长。

### 应用场景

1. 计算机简单搜索

2. 内存或硬盘内容检查

3. 过滤垃圾邮件中的关键词

4. 网络监控寻找关键词

5. 网页内容抓取

### 目标

高效准确地在大文本流或文件中定位模式串。

### 例子

1. 网络监控只查找"tank"或"dorm"相关信息

2. 利用网页结构定期抓取股价信息

### Java实现原理

1. 读取stdin或文件作为主串

2. 调用String indexOf()方法定位模式串第一次出现位置

3. 依据格式获取目标子串

### 算法介绍

将介绍解决串搜索问题的一些算法,包括效率极高的硬件适 solutions。

### 总结

串搜索问题广泛存在,高效算法对许多应用都至关重要。

## 67. 0lCtBReMZoE

### 朴素匹配算法

朴素匹配算法是串搜索问题最基本的解法,它以每次匹配一个字符的方式进行比较,直到发现第一个不匹配字符位置。

### 实现

1. 设定文本指针i和模式指针j,从0开始

2. 比较text[i]与pattern[j],若相等则i,j同时加1,继续匹配

3. 若不等,将j重置为0,i加1继续下一位置匹配

4. 重复2,3步骤直到文本结束

### 问题分析

1. 时间复杂度为O(MN),M和N分别是模式串和文本长度

2. 每次都需要回溯模式指针,不适合数据流场景

3. 存在大量重复匹配情况,如全相同字符文本和模式串

### 算法改进

1. 考虑时间复杂度是否能做到与模式串长度无关

2. 如何避免回溯文本,适用于数据流场景

### 总结

朴素匹配算法简单但不够高效,后续算法将针对其问题提出更好的解决方案。

## 68. wpcXh0RylPw

### 模式匹配算法改进

朴素匹配算法存在效率低下和回溯文本的问题。

### 击鼓扫把法(Boyer-Moore)

1. 从模式串后向前匹配

2. 当发现不匹配,会根据模式串后字符信息跳过匹配部分

3. 跳过字符数量与模式串后缀信息相关,但与文本长度无关

4. 避免了重复匹配、回溯文本的问题

### 优点

1. 时间复杂度不再与模式串长度相关,而与文本长度相关

2. 实时处理数据流,避免保存文本缓冲区

### 工作原理

1. 记录模式串每个字符在模式串中最后出现位置的表

2. 当发现不匹配,将模式串后移到表lookup得到的位置继续匹配

3. 这样能最大限度跳过重复匹配区域

### 结论

击鼓扫把法通过利用模式串后缀信息,克服了朴素匹配算法的两个主要问题,使得串搜索问题得到很好解决。

## 69. MVrVZwrI8aw

### Boyer-Moore算法

Boyer-Moore算法从模式串右侧开始向左匹配主串,发现不匹配直接跳过匹配部分。

### 工作原理

1. 预处理模式串,记录每个字符最后出现位置

2. 匹配从右到左。发现不匹配直接跳过模式串指定长度

3. 跳过长度根据模式串后缀信息及预处理结果决定

### 实现

1. 初始化跳跃表,记录每个字符在模式串最后位置

2. 匹配时计算跳过长度skip=i-跳跃表结果

3. i+=skip,从新位置继续匹配

### 特点

1. 时间复杂度为O(N/M),随模式串长度增长搜索效率提高

2. 实时处理数据流,无需保存文本

3. 普遍情况下较KMP更快,但存在最坏情况O(NM)

4. 通过修改预处理表可优化最坏情况,保持线性时间

### 总结

Boyer-Moore算法利用模式串后缀信息最大限度跳过匹配,在实际应用中效率通常优于KMP,是一种常用的串搜索算法。

## 70. BsxPFYP4afE

### 拉宾-卡普算法

拉宾-卡普算法是一种非常灵活高效的子串匹配算法。

### 工作原理

1. 将模式串和文本串映射为巨型质数取模后的散列值

2. 利用贺纳算法一位一位计算散列值,并进行模运算避免大数计算

3. 散列值相同则可能匹配,需进一步比对模式串与文本串字符

### 算法优点

1. 时间复杂度线性,仅与文本长度有关,而与模式串长度无关

2. 易于扩展,可以找多个模式或二维搜索

3. 理论上可能误匹配率极低,通过调整质数大小可以降至接近0

4. 可分为保证结果正确的拉斯维加斯版本和快速但极低概率错误的蒙特卡罗版本

### 实现步骤

1. 预处理计算散列函数与模式串散列值

2. 滑动窗口计算文本散列值并与模式串散列值进行匹配

3. 散列值匹配需进一步比对模式串与子串字符

4. 模式串匹配成功则找到模式在文本中的位置

总之,拉宾-卡普算法利用散列技巧巧妙解决了子串匹配问题。

## 71. hiMiyXzHZKA

### 正则表达式简介

正则表达式用来描述一个字符串集合。我们通过四种基本操作来构建正则表达式:

- 连接操作:将字符按顺序连接。匹配整个字符序列。
- 或操作:将两个正则表达式用竖线 "|" 分隔,用来匹配其中一个字符串。
- 封闭操作:在字符或正则表达式后加星号 "*",表示该字符或正则表达式0次或多次重复。
- 括号操作:将正则表达式括在括号内,则可以对其进行连接、封闭或其他操作。

此外,还有一些语法糖来方便使用:

- 通配符点".",可以匹配任意一个字符。
- 字符集"[a-z]",可以匹配指定范围内的任意字符。
- 加号"+",表示匹配1次或多次。
- 花括号"{}",可以指定重复次数。

正则表达式使用上述几种基本操作,可以描述任意复杂的字符串集合。它广泛应用于字符串搜索、数据验证等场景。

### 正则表达式常见应用

- 子串搜索:用点星表示任意字符,子串用括号括起来,再加两边点星表示0次或多次重复。
- 数据验证:例如用正则表达式验证电子邮件、手机号码、身份证等合法格式。
- 程序语言符号识别:如使用正则表达式定义标识符、关键字等语法元素。
- 文本解析:利用正则表达式识别文本结构,并进行有效处理。

除此以外,还有许多应用场景,如文本编辑、生物信息学等。正则表达式虽然表达能力强大,但过于复杂难读,使用不当也可能产生问题。总体来说,对于简单场景,正则表达式使用起来很方便。

## 72. HdApNMiAWy8

### 确定性有限状态自动机(DFA)和非确定性有限状态自动机(NFA)

DFA是一个简单的机器,用于识别给定字符串是否属于给定集合。它有明确定义的状态转换。

NFA比DFA更为通用,允许无输入地在状态之间进行转换。

### 正则表达式与自动机之间的关系

根据克里尼定理,对任何DFA都存在一个等效的正则表达式,反之亦然。

但DFA的状态数可能随着正则表达式长度呈指数增长,不实用。NFA可以避免这个问题。

### NFA的特点

NFA允许epsilon转换,即无输入下状态转换。这引入了非确定性。

NFA接受字符串需要考虑所有可能的状态变化 sequences。只要有一条序列识别所有字符即视为匹配。

### 解决NFA非确定性

无法确定下一个状态,但保证考虑所有可能路径。

算法中将模拟NFA操作,跟踪所有可能状态,判断是否存在一条路径识别字符串。

这样便可以利用NFA实现正则表达式匹配,以线性时间解决该问题。

## 73. DFTF_SG9pgI

### NFA的模拟

模拟NFA的操作过程是通过追踪在每步输入符号匹配后的所有可能状态来实现的。

具体来说,对每个输入字符i:

1. 保留上一步可能状态集合PC
2. 对PC中每个状态,检查是否有Epsilon跃迁,构建新的达到状态集合匹配
3. 对匹配集合运行DFS搜索所有Epsilon跃迁状态,构建下步可能状态集合PC
4. 重复规律直到输入结束

以此方式,我们可以在liner时间内模拟NFA对任意输入的接受决定。

### NFA模拟算法实现

具体实现中,使用集合PC记录每步可能状态。

初始化时PC包含从开始状态可达的所有状态。

对每个输入字符:

1. 检查PC中状态是否到达接受状态
2. 搜集字符匹配状态作为匹配集合
3. 对匹配集合运行DFS获取Epsilon跃迁闭包作为下步PC
4. 判断是否存在匹配所有输入且到达接受状态的路径

该实现利用了图深度优先搜索,时间复杂度为O(M×N),可有效模拟NFA。

总之,通过记录各步所有可能状态,我们高效地实现了NFA的模拟算法。这提供了理解和应用正则表达式的重要方法。

## 74. 8xVbYzsYCOM

### NFA构造算法

要从正则表达式构造对应的NFA非确定性有限状态自动机。

### 构造步骤

1. 初始化NFA,每个字符一个状态。最后一个为接受状态。

2. 左括号与或运算符入栈。

3. 字母加入匹配跳转。如有星号添加回路跳转。

4. 右括号弹栈,如为或运算加入跳过跳转。

5. 构造结束检验NFA是否满足正则语义。

### 值得注意细节

1. 星号操作需要加入三条回路跳转。

2. 或运算需要根据括号位置加入两条跳过跳转。

3. 括号嵌套使用栈保存信息。

4. 每个字符操作时间复杂度恒定,构造总时间线性。

5. 实现简单高效,以状态机模拟正则匹配。

6. 算法输出NFA图,为后续匹配识别提供支持。

总之,通过线性扫描和栈结构,得以有效构造NFA实现正则匹配。它消除了DFA限制,通过ε转换表达正则语义。

## 75. 0usHQGZvtrA

### NFA和DFA在描述字符串集中的等价性

NFA、DFA和正则表达式在描述一个字符串集合时具有等同的表达能力。

如果用其中一种方式可以描述一个字符串集合,则其他两种方式也都可以描述该字符串集合。

### 不可通过正则表达式描述的字符串集合

然而,也存在一些字符串集合无法通过正则表达式、DFA或NFA来描述,例如:

1. 回文字符串集合

2. 形式为ww的字符串集合(w是一个字符串)

3. 含义为palindromic但同时将字母a替换为t,c替换为g等的字符串集合

这些字符串集合都无法通过正则表达式来定义识别。

### Grep的实现原理

Grep通过构建NFA实现正则匹配:

1. 根据正则表达式构建NFA结构

2. 逐行读取标准输入文本

3. 对每一行文本使用构建的NFA进行识别判断是否匹配

4. 匹配则打印该行,不匹配则不打印

### Java中正则表达式的应用

Java内置了Pattern和Matcher类支持正则表达式操作:

1. Pattern用于构建NFA结构

2. Matcher用于NFA的模拟与识别

3. 可以直接判断字符串是否匹配,也可以提取匹配子串

此外,还可以实现搜索词汇表或网页 harvesting正则表达式匹配片段的功能。

但需注意,一些正则实现的时间复杂度可能为指数级,可能导致漏洞攻击。

## 76. YpDz8jZGBiI

### NFA和DFA的等价性

NFA(非确定有穷自动机)、DFA(确定有穷自动机)和正则表达式在描述字符串集合时具有等价性:

- 如果一个字符串集合可以用其中一种方式描述,那么也可以用其他两种方式描述

### 不正则语言

但是也存在一些字符串集合无法用正则表达式、NFA或DFA来描述,比如:

- 回文字符串集合
- 形式为ww的字符串集合(w是一个字符串)
- 含义为回文但同时将某些字母替换的字符串集合

### Grep实现原理

Grep通过构建NFA来实现正则匹配:

1. 根据正则表达式构建NFA结构
2. 逐行读取标准输入文本  
3. 对每一行文本使用构建的NFA进行识别判断是否匹配
4. 匹配则打印该行,不匹配则不打印

### Java中的正则表达式应用

Java内置Pattern和Matcher类支持正则表达操作:

1. Pattern用于构建NFA结构
2. Matcher用于NFA的模拟与识别
3. 可以直接判断字符串是否匹配,也可以提取匹配子串

此外,也可以实现搜索词汇表或网页的harvesting功能,提取正则匹配片段。但某些正则匹配实现的时间复杂度可能为指数级,可能导致安全漏洞。

## 77. -eqjf5_kOM4

### 运行长度编码

运行长度编码是一种简单有效的数据压缩方法。它利用了在数据流中经常出现的重复字符或者位的特点。

### 压缩原理

直接记录重复位数串的数量,而不是逐个记录每个重复位或者字符,从而节省空间。

### 实现步骤

1. 统计数据流中0和1的连续重复位数

2. 将重复位数以固定比特数(如8比特)表示,替代原始数据

3. 解码时,根据重复位数串重建原始数据

### 参数选择

1. 重复位数用多少比特表示需要权衡原始数据规模和重复位数可能范围

2. 实际情况下8比特在240KB以下数据可完全覆盖

3. 超长重复位数可采用插入0串的方法处理

### 应用实例

适用于图像、文本等具有大量重复区域的数据。比如黑白图像中空白区域,可以极大减少存储空间。

运行长度编码算法实现简单,压缩效果明显,广泛应用于JPG、传真等压缩标准中。

## 78. unNTMGuIyO4

### 运行长度编码的压缩与解压算法

运行长度编码包含压缩和解压两个阶段。

#### 压缩算法

1. 扫描原始数据,统计0和1的连续重复位数

2. 将重复位数以固定位数(如8位)表示,形成重复次数序列

3. 输出重复次数序列作为压缩后数据

#### 解压算法

1. 读取重复次数序列

2. 根据序列中每个重复次数,分别输出对应的0或1

3. 重复进行直到读取完全部重复次数序列

4. 输出的二进制数据即为解压后的原始数据

### 关键点

1. 压缩输出重复次数序列,减少冗余

2. 解压直接根据重复次数还原原始数据

3. 压缩和解压算法简单高效

4. 可适用于文件、图像和其他数据类型

5. 对重复数据部分具有很好的压缩效果

运行长度编码应用广泛原因就是其简单高效的压缩和解压实现,能很好地利用数据中的重复模式进行压缩。

## 79. EACpLudV-PU

### 运行长度编码的延伸方法

运行长度编码可以根据不同应用场景进行一些延伸:

#### 多值编码

对于不止二值(0/1)的数据,可以统计各个值的重复次数序列。

#### 双向编码

不仅统计0到1的变化,也统计1到0的变化,利用更多信息进行压缩。

#### 大对象编码

对于比说明长度还长的重复串,不再使用计数方式,而是直接复制重复部分。

#### 杂凑表编码

如果重复值较多但不是连续的,可以建立映射表,用更短的代码表示值。

#### 等长分组

将重复次数分组,每个组使用定长表示,处理超长重复次数且保证解码时长度顺序。

#### 上下文编码

考虑上下文信息,利用重复值相关联可能性进行熵编码,获得更高压缩率。

#### 预测编码

利用重复规律进行预测,编码预测错误部分,增强压缩效果。

以上方法都在原有基础上增加信息利用率,可进一步提高运行长度编码的数据压缩效果,在不同数据类型中都有很好的应用。

## 80. upinO0f20QY

### 算法问题分类

可以将算法问题分类为不同难度级别,根据解决某个问题需要的时间复杂度来衡量。

例如排序问题可以归类为Θ(nlogn)级别,而线性时间内解决问题则属于更低级别。

对新问题难度难以判断时,可以利用已有高效算法来给问题下界。

### 问题间的联系

利用某个问题的解法来帮助解决其他问题,这就是问题间的关联性。

一个问题可通过传递性约简成另一个以知名算法可解的问题,进而得出原问题的解法。

如通过排序找到中位数,通过排序判断数组元素是否唯一。

### 问题约简

如果问题A可以透过逻辑变换变成已有高效算法可解的问题B,则称A约简成B。

约简包括实例转换、算法调用、结果转换三个阶段:

1. 将A实例转换成B实例

2. 调用B问题已有算法

3. 将B结果反向转换成A解

若约简开销为常数级,则A问题时间复杂度与B问题相当。

问题约简是判断问题难易程度和设计新算法的重要工具。

## 81. j99MpizdSDU

### 问题约简实例

1. 凸包问题通过排序解决:采用Graham扫描算法,利用排序结果顺序扫描构建凸包,时间复杂度Θ(nlogn)。

2. 无向图最短路径通过有向图最短路径解决:将无向边替换为双向边,调用有向图算法。时间复杂度Θ(ELogn)。

3. 中位数和唯一性检验通过排序解决。

4. 调度问题通过拓扑排序解决。

5. 奇异价值问题通过最短路径解决。

### 问题约简优点

利用已有高效算法,设计新问题算法。如果旧算法运行时间为f(n),新问题时间复杂度也可能在f(n)级别。

### 问题约简案例

通过排序问题约简还解决了:元素processing、应用排序问题如任务调度等。

通过图算法约简还解决了:奇异价值、平行调度、 bipartite匹配等问题。

通过线性规划也可以约简最大流和最短路径问题。

问题约简是一个重要的算法设计技巧,帮助了解和解决众多经典问题。

## 82. Zl3YgNRQQks

### 证明问题下界的重要方法:问题约简

通过问题约简,可以将一个新问题约简为已有高效算法可解的旧问题。如果该旧问题已知时间下界为T(n),则新问题时间下界也不可能低于T(n)。

#### 约简的关键点:

1. 约简成本不能高,一般为线性时间。

2. 可以将一个问题的下界“传导”给另一个问题。

3. 如果通过约简可以更快解决旧问题,那么原问题也可以更快解决,违反旧问题的时间下界。

#### 例子:

假设排序问题时间下界为O(nlogn),则通过线性时间约简排序为凸包问题,可以证明凸包问题时间下界也为O(nlogn)。

#### 其他应用:

同理可以证明许多计算几何和图算法问题时间下界,如最短路径、匹配问题等。问题约简深入说明了算法难易的内在本质,给出问题难易程度的有效指导。

总之,问题约简是证明问题难易程度非常重要的方法,为设计新的高效算法提供了理论依据。它帮助分类和系统理解了许多核心算法问题。

## 83. D7cHtK824gc

### 通过约简分类问题难易程度

利用问题间的约简关系,可以初步归类问题难易程度。

比如将问题A约简成问题B,由于B已有高效算法,则A问题难易程度不低于B。

此外,若A、B互相约简,则说明它们具有相同的计算量要求。

### 具体操作

1. 设计将问题A约简为问题B的实例转换和结果转换算法

2. 调用问题B的已有高效算法

3. 将B结果转换回A解

若约简成本为常数级,则A、B计算量相同

### 约简实例

如利用排序算法解决凸壳问题、通过图算法解决匹配问题等

### 问题难易程度来源

某些基础问题难易如整除、平方根等,其本身计算量难确定

但通过互相约简显示它们计算量相当

### 计算量下界

如果问题A可以约简为已知下界为f(n)的问题B,则A问题下界不低于f(n)

### 问题等价类

经研究许多问题可以约简并归入不同等价类,代表复杂度未知但相同

问题约简有助理解和分类算法问题,为后续设计高效算法奠定理论基础。

## 84. 57 1 Brewer's Problem

### 问题约简在实际开发中的隐患

在大型软件项目开发中,问题约简如果未正确理解,会带来困难:

1. 两个开发人员分别负责实现A和B问题

2. A人通过约简利用B实现A;B人通过约简利用A实现B

3. 从而形成递归约简,导致开发不能结束

### 原因分析

- 问题约简关系没有协同研究统一理解

- 每个负责人仅考虑自己任务而忽略整体影响

- 系统设计未规划问题实现依赖关系

### 解决方法

- 建立约简关系知识库,使每个人了解整体

- 规划清楚任务职责范围和依赖关系

- 采用库函数或独立实现操控实现顺序

### 总结

问题约简在理论上证明问题难易,但在实际开发须慎用

正确理解和合作才能发挥其优势,否则将引起困难

正确应用需要整体设计和协同研究问题关系

## 85. 58 2 Simplex Algorithm

### 简单算法原理

简单算法采用基本可行解的思想,目标是通过重复地进行单面体搜索来找到最优解。

它从某个基本可行解出发,通过轮换选择让某个变量进入基中并且其他变量消去,从一个基本可行解移动到相邻的一个,直到找不到更优解为止。

### 初始化

取初值时,选择所有松弛变量进入基,其它变量置0,这样形成一个基本可行解。

### 选择轮换元素

轮换元素是目标函数中正系数最大的变量列。行选择采用最小比例规则,使右手边大于0。

### 进行轮换

将轮换元素解为被轮换变量, SUBSTITUTE 到其他等式中,使该列元素消为0。

### 判断结束条件

如果目标函数中不存在正系数了,那么当前基本可行解就是最优解。

### 运算法则

迭代进行上述步骤,简单且有效率地找到线性规划问题的解。它利用线性代数的思想,通过基的转换实现问题的优化。

## 86. 55 3 Establishing Lower Bounds

### 设立问题下界的重要性

设立问题的时间下界可以帮助我们评估问题难易程度,合理设计算法以及调优算法性能。

### 设立下界的困难性

设立下界需要讨论所有可能的算法,这通常很难进行。需要进行复杂的递规或者归纳证明。

### 排序问题下界证明

利用决策树模型证明,任何基于比较操作的排序算法,在最坏情况下时间复杂度下界为Ω(nlogn)。

### 通过约简传播下界

如果问题A可以在常数时间内约简成问题B,且B问题已知下界为f(n),则A问题下界也不低于f(n)。

### 凸包问题下界证明

在二次决策树模型下,将排序问题约简为凸包问题。由于排序下界为Ω(nlogn),因此凸包问题时间下界也为Ω(nlogn)。

### 约简必须满足条件

约简实现复杂度不能过高,常见情况下采用线性时间约简。

### 下界设立的重要性

用于指导研究难易程度,避免重复投入精力在无法突破下界的算法设计上。

约简是证明问题难易最有效的方法,也是下界理论的重要来源。

## 87. 59 3 Simplex Implementations

### 简单算法实现难点

1. 选择入基变量(轮换元素选择规则)

2. 对基表进行成形(确保每次迭代后仍为基表)

3. 判断最优性

### 常见实现方法

1. 最边工厂法:选择离目标最近的边进入基。

2. 二次增广法:将原问题增加一个目标,旨在提前结束。

3. 最优rayed法:利用基点信息,跳过部分迭代。

4. 内点法:将原问题放松,在内点迭代求解。

### 实现考虑因素

1. 数值稳定性:基矩阵不失踪零行列。

2. 计算效率:减少乘法次数,利用已存储信息。  

3. 精度问题:如容错率选择等。

4. 可视化效果:辅助理解算法运算过程。

5. 问题类型:针对整数规划等特殊问题优化实现。

6. 计算能力:串行或并行实现等。

简单算法各种实现,在实用性和应用广泛性上都有很好的表现。

## 88. 60 4 Linear Programming Reductions

### 常见问题约简为线性规划问题

许多优化问题都可以约简为线性规划问题,通过定义变量、约束条件和目标函数实现问题建模。

### 最大流问题约简示例

变量定义为各边流量,约束为流量大于0小于边容量,流量保守在每个节点,目标为源到汇的最大流量。

### 二分匹配问题约简

变量定义为每个匹配边是否存在,约束为每个实体最多匹配一个目标,目标为最大匹配边数量。通过紧凑性定理,最优解值为0-1,直接使用线性规划求解。

### 优点

问题建模简单,利用线性规划软件快速求解。模型更换容易,添加约束更方便。

### 形式差异

专门算法解法优于线性规划软件,但模型更加灵活。理论上任何问题都可以约简为线性规划,但难度不同。

### 结论

线性规划是近50年来最接近通用问题求解模型。了解其推广性和优势对问题解决很重要。

## 89. 61 1 Introduction to Intractability

### 难解性问题概念

某些问题无论算法设计得多完美,都不存在多项时间内的确定性算法求解。这类问题称为难解性问题。

### P和NP类问题

P类问题被认为可在多项时间内解决。NP类问题在多项时间内验证解是否正确,但未知是否可求解。

### NP完全性

如果某问题可以在多项时间内归约成已知NP完全问题,则该问题也是NP完全问题。

### NP完全问题难解性依据

假若P≠NP,则没有多项时间内算法可解决NP完全问题。目前没有证明P是否等于NP,但普遍认为P≠NP。

### 影响因素

问题规模、算法时间复杂度、硬件性能限制都可以导致问题实际难以在可接受时间内解决,称为难解问题。

### 本质区别

难解问题可能有更好算法,而难解性问题原则上无法在多项时间内解决,是理论上的限制而不是实际操作上的限制。

## 90. 62 2 Search Problems

### 搜索问题概念

搜索问题是一类通过探索解空间来寻找解的问题。其特征是:可以高效验证给定解是否正确;输入规模随问题实例增加。

### 典型搜索问题

1. LSolve:给出线性方程组,找出解。
2. LP:给出线性不等式组,找出满足条件的解。
3. 满足问题:给出公式组,判断是否存在令公式组成立的变量赋值。
4. 整数线性规划:线性规划中变量限定为0-1。
5. 最小因数问题:给出整数,找出其最小的非平凡因数。

### 搜索问题判断标准

可高效核对给定解是否正确是搜索问题的关键要求。高效这里指算法时间随问题规模的增大而多项式增长。上述问题都满足此条件,所以都是搜索问题。

### 与其他问题类型关系

决策问题和优化问题也可以表示为搜索问题。理论结论适用于所有这类问题。但论述时选择搜索问题可以避免理论漏洞。

## 91. 63 3 P vs NP

### P类问题

P类问题是指可以在多项时间内通过确定性算法求解的问题。

### NP类问题

NP类问题是指是否存在解可以在多项时间内验证,但未知是否有多项时间内的解法。

### NP完全性

如果一个NP问题可以多项时间内通过对已知NP完全问题的减化来解决,则该问题也是NP完全问题。

### P与NP关系猜想

假设P≠NP,则NP完全问题没有多项时间内的确定算法。

### NP完全问题含义

如果P=NP是真的,那么NP完全问题将具有多项时间算法。如果P≠NP,那么NP完全问题是本质上难以在多项时间内解决的。

### 影响

P与NP关系猜想影响问题难易程度判断,算法设计策略选择。NP完全问题目前只能采用近似或随机算法求解。

### 开展方向

重大猜想目前仍未解决。相关工作包括尝试证明P≠NP,找到新型NP完全问题,在特定条件下求解NP完全问题等。

## 93. 65 5 NP Completeness

### NP完全性概念

如果一个NP问题可以在多项时间内通过将已知的NP完全问题还原为该问题来解决,则该问题也是NP完全问题。

### Cook-Levin定理内容

定理认为任何可以在非确定性Turing机在多项时间内计算解的问题,都可以编码为一个SAT问题实例,如果能在多项时间内解决该SAT实例,就能解决原问题。

### Cook-Levin定理得出结论

任何NP问题都可以在多项时间内通过还原SAT来解决,也就是说任何NP问题都与SAT等价,都是NP完全问题。

### NP完全性重要性

若将NP问题还原为NP完全问题,就能说明该问题困难性等同于NP完全问题,在多项时间内难有确定算法求解。

### NP完全问题产生影响

已经证明的大量重要科学问题均为NP完全,就其本质难以在多项时间内解决,指导科学家采取近似或随机算法等方法解决难题。

### Ising模型案例分析

尽管50年有人研究,但2000年证明为NP完全,解释为何无法在多项时间内找到确定算法,指导研究方向。

## 94. 66 6 Coping with Intractability

### 难于求解问题定义

如果一个问题没有多项时间算法可以求解任何实例,即为难于求解问题。

### 处理难于求解问题方法

1. 放弃求解任何实例,只解实际问题实例

2. 简化问题,求解现实需求问题的特殊子案例

3. 放弃最优解要求,求近似解或在解集中选择

4. 在实际问题规模范围内,存在多项时间算法

### 优化问题方法

许可近似解不必保证最优,比如旅行商问题

### 决策问题方法

在实际实例规模范围内,也可能有多项时间算法

### 其它方法

限定问题特性简化问题难度,如限制SAT问题项数等

## 95. Computer Science 2: Data Structures and Algorithm Analysis in Java [1/3]

### 本节介绍

介绍爪哇语言实现数据结构和算法分析的计算机科学课程内容。

### 第一周内容

第一周为数学算法分析,计算运行时间复杂度。

### 第二周内容

实现数组中是否存在两个数之和等于给定目标值的算法。通过从数组两端开始遍历,计算两个数字和与目标值的大小关系来实现。

### 第三周内容

包括实现整数转二进制中1的个数、数组中的最小值、棋盘上是否能从起点移动到终点的算法。利用递归的思想来解决问题。

### 算法实现

提供了源代码及测试用例,复现课程任务需要编写的算法程序。同时给出了相应的输出结果以检查程序是否正确。

### 第四周内容

转换不同类型数组的表示,如二维矩阵与一维列表的相互转换。以及提供源代码及测试用例供学习参考。

## 96. Computer Science 2: Data Structures and Algorithm Analysis in Java [2/3]

### 本节内容

本节介绍了哈夫曼编码树算法和贪心算法在火车站路线排程问题中的应用。

### 哈夫曼编码树算法

给出了实现哈夫曼编码树算法的源代码,运行时间复杂度为O(nlogn)。算法以树的形式表示不同字符出现的频率,构建最优的二叉码表。

### 火车站路线排程问题

问题描述:根据输入的不同火车站之间的出发和到达时间,寻找从起点站到终点站耗时最短且罚点最少的路线。

### 算法步骤

1. 判断是否能从起点站到达终点站
2. 如果可以,计算需要耗费的总时间
3. 计算从各个火车站出发后到达下个站的罚点,将其累加作为最终罚点
4. 采用贪心策略,优先选择出发时间最早的线路,但需要回溯若无法到达下站
5. 提供多组不同规模测试用例

### 代码分析

代码清晰注释,逻辑层次分明。主要使用深度优先搜索回溯所有可能的线路,记录最优解。提供测试结果与问题描述中的示例相匹配。

### 总结

本节系统介绍了哈夫曼编码树和贪心算法在解决火车站路线规划问题中的应用,同时给出详细的源代码及测试用例,有利于理解和学习这两个算法。

## 97. Computer Science 2: Data Structures and Algorithm Analysis in Java [3/3]

### 本节主要内容

本节主要讲解了动态规划和回溯搜索算法在游戏跳格子和解迷宫问题中的应用。

### 游戏跳格子问题

给定起始数字和格子移动规则,计算从起始数字跳到0的最少步数。利用动态规划和备忘录技巧,实现递归算法找出全局最优解。

### 解迷宫问题

给定迷宫地图,使用深度优先搜索回溯算法判断机器人是否能从起点走到终点。将地图表示为二维数组,递归检测每个方向是否可行。

### 代码实现与测试用例

提供了完整的Java代码及不同规模的输入文件测试用例。代码设置明确的函数和运行流程,注释良好。通过跑例测试效果与问题描述 Match。

### 动态规划思路分析

利用备忘录数组存储子问题解,避免重复计算。分别处理四种移动规则,取其中成本最小者作为当前状态解。通过递归 bottom-up方式求解全局最优解。

### 回溯搜索思路

从起点开始 depth优先搜索所有路径,记录已经访问点防止回退。递归每个方向直至出界或找到通路,判断是否能从起点达到终点。

### 总结

本节系统阐述了动态规划和回溯搜索在有限决策问题中的应用,给出详细代码实现,有利于理解这两类算法的思路。

## 98. Approximation Algs. - Lecture 19

### 近似算法概述

近似算法用于求解复杂问题的近似解,允许结果不必是最优。

### 物品包裹问题

给定物品体积和价值,将其装入容量有限的背包中使得总价值最大。

### 完全背包问题

每个物品可以使用多次,通过动态规划在O(nV)时间内求解,其中n是物品个数,V是背包容量。

### 0-1背包问题

每个物品只能使用一次。使用贪心策略得到3/2近似率。

### 最大权独立集问题

给定图,求其中节点之间不相邻的最大集合。问题难求解,采用贪心策略近似。

### 任务调度问题

给定任务完成时间和价值,求满足截止期内的最大价值任务集。贪心策略可得到2近似率。

### 总结

近似算法在难解决的最优化问题中,放弃严格的最优要求,换取在多项时间内找到性能接近最优的可行解。提供了常用近似问题和算法的概述。

## 99. Coding Challenge #35.1: Traveling Salesperson

### 旅行商问题描述

给定城市坐标,求出在所有城市间仅访问一次顺序的最短路径。

### 问题难度

求全局最优解为NP完全问题,无法在多项时间内解决。

### 近似算法思路

1. 贪心策略:随机选择一个城市作为起点,按距离排序访问每个城市

2. 2-近似:构建最小生成树,访问根节点后按树形遍历其他节点

3. 2.5-近似:构建完全图,每条边权为两城市间距离之和,取权值最小周回路

### 贪心算法实现

1.导入输入城市坐标

2.随机选起点

3.按距离排序其他城市

4.遍历访问每个城市一次

5.输出排序后路径和总长度

### 测试用例

提供输入文件格式和测试输出,验证算法是否按预期运行。

### 总结

解决NP完全问题时,采用近似算法成为有效方法。本任务给出旅行商问题贪心近似算法的概述和Python实现,有助于理解这类问题及其解决思路。

## 100. Coding Challenge #35.2: Lexicographic Order

### 问题描述

给出整数列表,输出其中元素按字典序排列的所有排列方式。

### 排列算法思路

1. 导入整数列表

2. 使用递归回溯法生成所有排列组合

3. 每次选择待排整数,固定在各位置上递归生成排列

4. 若排列重复,跳过继续生成下一个排列

5. 输出所有排列,并检查是否按字典序排列

### 代码实现

定义回溯函数recurse(),参数包括序列、路径数组和路径长度。

步骤1选择第i个元素,步骤2固定在第一位置并递归生成子序列,步骤3回溯移除元素。

检查是否重复排列,输出结果时按字典序打印所有排列方式。

### 测试用例

提供示例输入序列以及预期输出结果,确认算法能正确工作。

### 总结

本题使用递归回溯法解决全排列问题,给出清晰直观的算法思路和Python代码实现。能帮助理解排列、组合类问题的解法。